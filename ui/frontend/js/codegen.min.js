const __version__='0.1.5';const __VERSION__=__version__;const __AUTHOR__='Ichiru Take';const APP_NAME='PGTUNER_DBA';const APP_NAME_LOWER=APP_NAME.toLowerCase();const APP_NAME_UPPER=APP_NAME.toUpperCase();const PG_ARCHIVE_DIR='/var/lib/postgresql/mnt/archive/wal';const PG_LOG_DIR='/var/log/postgresql';const MULTI_ITEMS_SPLIT=';';const K10=1000;const Ki=1024;const M10=K10**2;const Mi=Ki**2;const G10=K10**3;const Gi=Ki**3;const T10=K10**4;const Ti=Ki**4;const P10=K10**5;const Pi=Ki**5;const E10=K10**6;const Ei=Ki**6;const DB_PAGE_SIZE=8*Ki;const BASE_WAL_SEGMENT_SIZE=16*Mi;const RANDOM_IOPS='random_iops';const THROUGHPUT='throughput';const NANOSECOND=1e-9;const MICROSECOND=1e-6;const MILLISECOND=1e-3;const SECOND=1;const MINUTE=60*SECOND;const HOUR=60*MINUTE;const DAY=24*HOUR;const WEEK=7*DAY;const MONTH_TIME=Math.round(30.5*DAY);const YEAR_TIME=Math.round(365.25*DAY);function getJSVersion(){let version=undefined;if(String.prototype.trim){version=5;if(Array.prototype.map){version=6;if(Array.prototype.includes){version=7;if(Object.values){version=8;if(Promise.prototype.finally){version=9;if(Array.prototype.flat){version=10;if(String.prototype.matchAll){version=11;if(String.prototype.replaceAll){version=12;if(Object.hasOwn){version=13;if(Array.prototype.toSorted){version=14;}}}}}}}}}}
if(version){return"1."+version;}else{return"unknown";}}
let javascript_version=getJSVersion();console.log(`JavaScript version: ${javascript_version}`);const bytesize_to_hr=(bytesize,decimal=false,separator=' ')=>{if(typeof bytesize!=='number'){bytesize=Math.floor(bytesize);}
if(bytesize===0){return`0${separator}B`;}
if(bytesize<0){throw new Error('Negative byte size is not supported');}
let divisor,units,final_unit;if(decimal){divisor=1000;units=['B','KB','MB','GB','TB','PB'];final_unit='EB';}else{divisor=1024;units=['B','KiB','MiB','GiB','TiB','PiB'];final_unit='EiB';}
let num=bytesize;for(let unit of units){if(Math.abs(num)<divisor){if(unit==='B'){return`${num.toFixed(0)}${separator}${unit}`;}else{return`${num.toFixed(1)}${separator}${unit}`;}}
num/=divisor;}
return`${num.toFixed(1)}${separator}${final_unit}`;}
const realign_value=(value,page_size=DB_PAGE_SIZE)=>{if(typeof value==='number'){value=Math.floor(value);}
const d=Math.floor(value/page_size);const m=value%page_size;return[d*page_size,(d+(m>0?1:0))*page_size];}
const cap_value=(value,min_value,max_value,redirectNumber=null)=>{if(redirectNumber&&redirectNumber.length===2&&value===redirectNumber[0]){value=redirectNumber[1];}
return Math.min(Math.max(value,min_value),max_value);};function generalized_mean(x,level,round_ndigits=4){if(level===0){level=1e-6;}
const n=x.length;const sumPower=x.reduce((acc,val)=>acc+Math.pow(val,level),0);const result=Math.pow(sumPower/n,1/level);if(round_ndigits!==null){if(typeof round_ndigits!=='number'){throw new Error("The 'round_ndigits' property must be a number.");}
if(round_ndigits<0){throw new Error("The 'round_ndigits' property must be a non-negative number.");}}
const factor=Math.pow(10,round_ndigits);return Math.round(result*factor)/factor;}
const merge_extra_info_to_profile=(profiles)=>{for(const[unused_1,[unused_2,items,extra_default]]of Object.entries(profiles)){for(const[default_key,default_value]of Object.entries(extra_default)){for(const[itm_name,itm_value]of Object.entries(items)){if(!(default_key in itm_value)){itm_value[default_key]=default_value;}}}}
return null;};const type_validation=(profiles)=>{for(const[unused_1,[scope,category_profile,unused_2]]of Object.entries(profiles)){for(const[mkey,tune_entry]of Object.entries(category_profile)){if(typeof tune_entry!=='object'||tune_entry===null){throw new Error(`The tuning key body of ${mkey} is not a dictionary.`);}
if(typeof mkey!=='string'){throw new Error(`The key ${mkey} is not a string.`);}
const keys=mkey.split(MULTI_ITEMS_SPLIT).map(k=>k.trim());if(!keys.every(k=>k&&!k.includes(' '))){throw new Error(`The key representation ${mkey} is empty or contains whitespace.`);}
if(!('default'in tune_entry)){throw new Error(`The default value is not found in the tuning key body of ${mkey} this could lead to no result of tuning`);}
if(typeof tune_entry['default']==='function'||tune_entry['default']===null){throw new Error(`${mkey}: The default value must be a non-null static value.`);}
if('tune_op'in tune_entry&&typeof tune_entry['tune_op']!=='function'){throw new Error(`${mkey}: The generic tuning operation must be a function.`);}
if('instructions'in tune_entry){if(typeof tune_entry['instructions']!=='object'||tune_entry['instructions']===null){throw new Error(`${mkey}: The profile-based instructions must be a dictionary of mixed instructions and static value.`);}
for(const[pr_key,pr_value]of Object.entries(tune_entry['instructions'])){if(typeof pr_key==='function'||pr_key===null){throw new Error(`${mkey}-ins-${pr_key}: The profile key must be a non-null, non-empty static value.`);}
if(pr_key.endsWith('_default')){if(typeof pr_value==='function'||pr_value===null){throw new Error(`${mkey}-ins-${pr_key}: The profile default value must be a non-null static value.`);}}else{if(typeof pr_value!=='function'){throw new Error(`${mkey}-ins-${pr_key}: The profile tuning guideline must be a function.`);}}}}}}
return null;};const rewrite_items=(profiles)=>{for(const[unused_1,[unused_2,items,unused_3]]of Object.entries(profiles)){const remove_keys=[];for(const[mkey,unused_4]of Object.entries(items)){if(mkey.startsWith('-')){remove_keys.push(mkey.slice(1));}}
for(const rm_key of remove_keys){if(rm_key in items){if(rm_key.includes(MULTI_ITEMS_SPLIT)){throw new Error(`Only a single tuning key is allowed for deletion: ${rm_key}`);}
delete items[rm_key];}else{console.warn(`The tuning key ${rm_key} is expected to be removed but not found in its scope or tuning result.`);}
delete items[`-${rm_key}`];}}
return null;};const show_profile=(profile)=>{for(const[key,value]of Object.entries(profile)){console.debug(key,value[1]);}
return null;}
const PG_WORKLOAD=Object.freeze({TSR_IOT:"tst",OLTP:"oltp",HTAP:"htap",OLAP:"olap",VECTOR:"vector",});class PG_SIZING{constructor(value){if(typeof value==='string'){if(!PG_SIZING.values.includes(value)){throw new Error(`Invalid value: ${value}`);}}else if(typeof value==='number'){value=PG_SIZING.values[value];}else{throw new Error(`Invalid value: ${value}`);}
this.value=value;}
static values=['mini','medium','large','mall','bigt'];static MINI=new PG_SIZING('mini');static MEDIUM=new PG_SIZING('medium');static LARGE=new PG_SIZING('large');static MALL=new PG_SIZING('mall');static BIGT=new PG_SIZING('bigt');static fromString(str){return new PG_SIZING(str)}
num(){return PG_SIZING.values.findIndex(t=>t===this.value);}
equals(otherEnum){return this.num()===otherEnum.num();}
toString(){return this.value;}
valueOf(){return this.value;}
[Symbol.toPrimitive](hint){if(hint==="number"){return this.num();}
if(hint==="string"){return this.value;}
return this.value;}}
const PG_BACKUP_TOOL=Object.freeze({DISK_SNAPSHOT:0,PG_DUMP:1,PG_BASEBACKUP:2,PG_LOGICAL:3,})
const PG_PROFILE_OPTMODE=Object.freeze({NONE:0,SPIDEY:1,OPTIMUS_PRIME:2,PRIMORDIAL:3,})
const PG_SCOPE=Object.freeze({VM:'vm',CONNECTION:'conn',FILESYSTEM:'fs',MEMORY:'memory',DISK_IOPS:'iops',NETWORK:'net',LOGGING:'log',QUERY_TUNING:'query',MAINTENANCE:'maint',ARCHIVE_RECOVERY_BACKUP_RESTORE:'backup',EXTRA:'extra',OTHERS:'others',});class PGTUNER_SCOPE{constructor(value){this.value=value;}
valueOf(){return this.value;}
disclaimer(){const dt=new Date().toLocaleString();if(this.value==='kernel_sysctl'){return`# Read this disclaimer before applying the tuning result
# ============================================================
# ${APP_NAME_UPPER}-v${__VERSION__}: The tuning is started at ${dt} 
# -> Target Scope: ${this.value}
# DISCLAIMER: This kernel tuning options is based on our experience, and should not be 
# applied directly to the system. Please consult with your database administrator, system
# administrator, or software/system delivery manager before applying the tuning result.
# HOWTO: It is recommended to apply the tuning result by copying the file and pasting it 
# as the final configuration under the /etc/sysctl.d/ directory rather than overwrite
# previous configuration. Please DO NOT apply the tuning result directly to the system 
# by any means, and ensure that the system is capable of rolling back the changes if the
# system is not working as expected.
# ============================================================
`;}else if(this.value==='database_config'){return`# Read this disclaimer before applying the tuning result
# ============================================================
# ${APP_NAME_UPPER}-v${__VERSION__}: The tuning is started at ${dt} 
# -> Target Scope: ${this.value}
# DISCLAIMER: This database tuning options is based on our experience, and should not be 
# applied directly to the system. There is ZERO guarantee that this tuning guideline is 
# the best for your system, for every tables, indexes, workload, and queries. Please 
# consult with your database administrator or software/system delivery manager before
# applying the tuning result.
# HOWTO: It is recommended to apply the tuning result under the /etc/postgresql/ directory
# or inside the $PGDATA/conf/ or $PGDATA/ directory depending on how you start your
# PostgreSQL server. Please double check the system from the SQL interactive sessions to 
# ensure things are working as expected. Whilst it is possible to start the PostgreSQL 
# server with the new configuration, it could result in lost of configuration (such as new 
# version update, unknown configuration changes, extension or external configuration from 
# 3rd-party tools, or no inherited configuration from the parent directory). It is not 
# recommended to apply the tuning result directly to the system without a proper backup, 
# and ensure the system is capable of rolling back the changes if the system is not working.
# ============================================================
`;}
return"";}}
PGTUNER_SCOPE.KERNEL_SYSCTL=new PGTUNER_SCOPE('kernel_sysctl');PGTUNER_SCOPE.DATABASE_CONFIG=new PGTUNER_SCOPE('database_config');const _FLOAT_PRECISION=4;const _STRING_PUNCTUATION=`"!"#$%&'()*+,-./:;<=>?@[\]^_{}|`;class PG_TUNE_ITEM{constructor(data){this.key=data.key;this.before=data.before;this.after=data.after;this.comment=data.comment||null;this.style=data.style??"$1 = $2";this.trigger=data.trigger;this.partial_func=data.partial_func||null;this.hardware_scope=data.hardware_scope;}
out(include_comment=false,custom_style=null){let texts=[];if(include_comment&&this.comment!==null&&this.comment.trim()!==''){const format_comment=String(this.comment).replace('\n','\n# ');texts.push(`# ${format_comment}`);texts.push('\n');}
const style=(custom_style??this.style)??"$1 = $2";if(!style.includes("$1")||!style.includes("$2")){throw new Error(`Invalid style configuration: ${style} due to missing $1 and $2`);}
const cleanedStyle=style.replace(/\s\s+/g,' ');const afterDisplay=this.out_display();const resultStyle=cleanedStyle.replace("$1",this.key).replace("$2",afterDisplay).trim();texts.push(resultStyle);return texts.join('');}
out_display(override_value=null){let value=override_value??this.after;if(this.partial_func&&typeof this.partial_func==='function'){value=this.partial_func(value);}else if(typeof value==='number'){value=value.toFixed(_FLOAT_PRECISION);value=value.replace(/(\.\d*?[1-9])0+$/,'$1').replace(/\.0+$/,'').replace(/\.$/,'.0');}
if(typeof value!=='string'){value=String(value);}
if(value.includes('.')){value=value.trim().replace(/(\.\d*?)0+$/,'$1');if(value.endsWith('.')){value+='0';}}
if(typeof this.after==='string'&&(this.after.includes(' ')||_STRING_PUNCTUATION.split('').some(p=>this.after.includes(p)))){value=`'${value}'`;}
return value;}
transform_keyname(){return this.key.split('_').map(part=>part.charAt(0).toUpperCase()+part.slice(1)).join(' ');}}
class PG_DISK_SIZING{constructor(code,throughput,iops){this._code=code;this._throughput=throughput;this._iops=iops;}
diskCode(){return this._code;}
throughput(){return this._throughput;}
iops(){return this._iops;}
_checkDiskType(diskType){const dt=diskType.toLowerCase();if(!PG_DISK_SIZING._diskTypeListV2().includes(dt)){throw new Error(`Disk type ${dt} is not available`);}
return this._code.startsWith(dt);}
static _diskTypeListV1(){return['hdd','san','ssd','nvmebox','nvmepciev3','nvmepciev4','nvmepciev5'];}
static _diskTypeListV2(){return['hdd','san','ssd','nvmebox','nvmepciev3','nvmepciev4','nvmepciev5','nvmepcie','nvme'];}
static _all(){return PG_DISK_SIZING.ALL;}
static _list(diskType=null,performanceType=null){let result=PG_DISK_SIZING._all().filter(disk=>{return diskType===null||disk._checkDiskType(diskType);});if(performanceType!==null){const keyFn=performanceType===THROUGHPUT?(d)=>[d.throughput(),d.iops()]:(d)=>[d.iops(),d.throughput()];result.sort((a,b)=>{const ka=keyFn(a),kb=keyFn(b);return ka[0]-kb[0]||ka[1]-kb[1];});}
return result;}
static _findMidpoints(disks,performanceType){const len=disks.length;const midpoint=Math.floor(len/2);if(len%2===0){const disk1=disks[midpoint-1];const disk2=disks[midpoint];return performanceType===THROUGHPUT?(disk1.throughput()+disk2.throughput())/2:(disk1.iops()+disk2.iops())/2;}else{const disk=disks[midpoint];return performanceType===THROUGHPUT?disk.throughput():disk.iops();}}
static _getBound(performanceType,disk01,disk02){const diskTable=PG_DISK_SIZING._list(null,performanceType);let lowerBound;if(disk01 instanceof PG_DISK_SIZING){const idx=diskTable.indexOf(disk01);const prev=idx>0?diskTable[idx-1]:disk01;lowerBound=disk01===prev?0:(performanceType===THROUGHPUT?(disk01.throughput()+prev.throughput())/2:(disk01.iops()+prev.iops())/2);}else{lowerBound=disk01;}
let upperBound;if(disk02 instanceof PG_DISK_SIZING){const idx=diskTable.indexOf(disk02);const next=idx<diskTable.length-1?diskTable[idx+1]:disk02;upperBound=disk02===next?2*(performanceType===THROUGHPUT?disk02.throughput():disk02.iops()):(performanceType===THROUGHPUT?(disk02.throughput()+next.throughput())/2:(disk02.iops()+next.iops())/2);}else{upperBound=disk02;}
if(upperBound<lowerBound){[lowerBound,upperBound]=[upperBound,lowerBound];}
return[Math.floor(lowerBound),Math.ceil(upperBound)];}
static matchBetween(performance,performanceType,disk01,disk02){const diskTable=PG_DISK_SIZING._list(null,performanceType);const lastDisk=diskTable[diskTable.length-1];if(performanceType===THROUGHPUT&&performance>=lastDisk.throughput()){return true;}else if(performanceType!==THROUGHPUT&&performance>=lastDisk.iops()){return true;}
const[lowerBound,upperBound]=PG_DISK_SIZING._getBound(performanceType,disk01,disk02);return performance>=lowerBound&&performance<upperBound;}
static matchDiskSeries(performance,performanceType,diskType,interval='all'){const disks=PG_DISK_SIZING._list(diskType,performanceType);if(!disks.length){throw new Error(`No disk type found when matching ${diskType}`);}
if(interval==='all'){return PG_DISK_SIZING.matchBetween(performance,performanceType,disks[0],disks[disks.length-1]);}
if(interval==='weak'){return PG_DISK_SIZING.matchBetween(performance,performanceType,disks[0],disks[Math.floor(disks.length/2)]);}else{return PG_DISK_SIZING.matchBetween(performance,performanceType,disks[Math.floor(disks.length/2)],disks[disks.length-1]);}}
static matchOneDisk(performance,performanceType,disk){return PG_DISK_SIZING.matchBetween(performance,performanceType,disk,disk);}
static matchDiskSeriesInRange(performance,performanceType,disk01Type,disk02Type){if(disk01Type===disk02Type){return PG_DISK_SIZING.matchDiskSeries(performance,performanceType,disk01Type);}
const disk01s=PG_DISK_SIZING._list(disk01Type,performanceType);const disk02s=PG_DISK_SIZING._list(disk02Type,performanceType);if(!disk01s.length||!disk02s.length){throw new Error(`No disk type found when matching ${disk01Type} and ${disk02Type}`);}
const diskCollection=[disk01s[0],disk01s[disk01s.length-1],disk02s[0],disk02s[disk02s.length-1]];const sortFn=performanceType===THROUGHPUT?(a,b)=>a.throughput()-b.throughput()||a.iops()-b.iops():(a,b)=>a.iops()-b.iops()||a.throughput()-b.throughput();diskCollection.sort(sortFn);return PG_DISK_SIZING.matchBetween(performance,performanceType,diskCollection[0],diskCollection[diskCollection.length-1]);}}
PG_DISK_SIZING.HDDv1=new PG_DISK_SIZING('hddv1',100,250);PG_DISK_SIZING.HDDv2=new PG_DISK_SIZING('hddv2',200,K10);PG_DISK_SIZING.HDDv3=new PG_DISK_SIZING('hddv3',260,2500);PG_DISK_SIZING.SANv1=new PG_DISK_SIZING('sanv1',300,5*K10);PG_DISK_SIZING.SANv2=new PG_DISK_SIZING('sanv2',330,8*K10);PG_DISK_SIZING.SANv3=new PG_DISK_SIZING('sanv3',370,12*K10);PG_DISK_SIZING.SANv4=new PG_DISK_SIZING('sanv4',400,16*K10);PG_DISK_SIZING.SSDv1=new PG_DISK_SIZING('ssdv1',450,20*K10);PG_DISK_SIZING.SSDv2=new PG_DISK_SIZING('ssdv2',500,30*K10);PG_DISK_SIZING.SSDv3=new PG_DISK_SIZING('ssdv3',533,40*K10);PG_DISK_SIZING.SSDv4=new PG_DISK_SIZING('ssdv4',566,50*K10);PG_DISK_SIZING.SSDv5=new PG_DISK_SIZING('ssdv5',600,60*K10);PG_DISK_SIZING.NVMeBOXv1=new PG_DISK_SIZING('nvmeboxv1',800,80*K10);PG_DISK_SIZING.NVMeBOXv2=new PG_DISK_SIZING('nvmeboxv2',1000,100*K10);PG_DISK_SIZING.NVMeBOXv3=new PG_DISK_SIZING('nvmeboxv3',1400,120*K10);PG_DISK_SIZING.NVMeBOXv4=new PG_DISK_SIZING('nvmeboxv4',1700,140*K10);PG_DISK_SIZING.NVMePCIev3x4v1=new PG_DISK_SIZING('nvmepciev3x4v1',2000,150*K10);PG_DISK_SIZING.NVMePCIev3x4v2=new PG_DISK_SIZING('nvmepciev3x4v2',2500,200*K10);PG_DISK_SIZING.NVMePCIev3x4v3=new PG_DISK_SIZING('nvmepciev3x4v3',3000,250*K10);PG_DISK_SIZING.NVMePCIev3x4v4=new PG_DISK_SIZING('nvmepciev3x4v4',3500,300*K10);PG_DISK_SIZING.NVMePCIev3x4v5=new PG_DISK_SIZING('nvmepciev3x4v5',4000,350*K10);PG_DISK_SIZING.NVMePCIev3x4v6=new PG_DISK_SIZING('nvmepciev3x4v6',4500,400*K10);PG_DISK_SIZING.NVMePCIev4x4v1=new PG_DISK_SIZING('nvmepciev4x4v1',4500,300*K10);PG_DISK_SIZING.NVMePCIev4x4v2=new PG_DISK_SIZING('nvmepciev4x4v2',5000,375*K10);PG_DISK_SIZING.NVMePCIev4x4v3=new PG_DISK_SIZING('nvmepciev4x4v3',5500,450*K10);PG_DISK_SIZING.NVMePCIev4x4v4=new PG_DISK_SIZING('nvmepciev4x4v4',6000,525*K10);PG_DISK_SIZING.NVMePCIev4x4v5=new PG_DISK_SIZING('nvmepciev4x4v5',6500,600*K10);PG_DISK_SIZING.NVMePCIev4x4v6=new PG_DISK_SIZING('nvmepciev4x4v6',7000,700*K10);PG_DISK_SIZING.NVMePCIev5x4v1=new PG_DISK_SIZING('nvmepciev5x4v1',7000,750*K10);PG_DISK_SIZING.NVMePCIev5x4v2=new PG_DISK_SIZING('nvmepciev5x4v2',8500,850*K10);PG_DISK_SIZING.NVMePCIev5x4v3=new PG_DISK_SIZING('nvmepciev5x4v3',9500,950*K10);PG_DISK_SIZING.NVMePCIev5x4v4=new PG_DISK_SIZING('nvmepciev5x4v4',11000,1100*K10);PG_DISK_SIZING.NVMePCIev5x4v5=new PG_DISK_SIZING('nvmepciev5x4v5',12500,1250*K10);PG_DISK_SIZING.NVMePCIev5x4v6=new PG_DISK_SIZING('nvmepciev5x4v6',14000,1400*K10);PG_DISK_SIZING.ALL=[PG_DISK_SIZING.HDDv1,PG_DISK_SIZING.HDDv2,PG_DISK_SIZING.HDDv3,PG_DISK_SIZING.SANv1,PG_DISK_SIZING.SANv2,PG_DISK_SIZING.SANv3,PG_DISK_SIZING.SANv4,PG_DISK_SIZING.SSDv1,PG_DISK_SIZING.SSDv2,PG_DISK_SIZING.SSDv3,PG_DISK_SIZING.SSDv4,PG_DISK_SIZING.SSDv5,PG_DISK_SIZING.NVMeBOXv1,PG_DISK_SIZING.NVMeBOXv2,PG_DISK_SIZING.NVMeBOXv3,PG_DISK_SIZING.NVMeBOXv4,PG_DISK_SIZING.NVMePCIev3x4v1,PG_DISK_SIZING.NVMePCIev3x4v2,PG_DISK_SIZING.NVMePCIev3x4v3,PG_DISK_SIZING.NVMePCIev3x4v4,PG_DISK_SIZING.NVMePCIev3x4v5,PG_DISK_SIZING.NVMePCIev3x4v6,PG_DISK_SIZING.NVMePCIev4x4v1,PG_DISK_SIZING.NVMePCIev4x4v2,PG_DISK_SIZING.NVMePCIev4x4v3,PG_DISK_SIZING.NVMePCIev4x4v4,PG_DISK_SIZING.NVMePCIev4x4v5,PG_DISK_SIZING.NVMePCIev4x4v6,PG_DISK_SIZING.NVMePCIev5x4v1,PG_DISK_SIZING.NVMePCIev5x4v2,PG_DISK_SIZING.NVMePCIev5x4v3,PG_DISK_SIZING.NVMePCIev5x4v4,PG_DISK_SIZING.NVMePCIev5x4v5,PG_DISK_SIZING.NVMePCIev5x4v6,];class PG_DISK_PERF{constructor(data={}){this.random_iops_spec=data.random_iops_spec??PG_DISK_SIZING.SANv1.iops();this.random_iops_scale_factor=data.random_iops_scale_factor??0.9;this.throughput_spec=data.throughput_spec??PG_DISK_SIZING.SANv1.throughput();this.throughput_scale_factor=data.throughput_scale_factor??0.9;this.per_scale_in_raid=data.per_scale_in_raid??0.75;this.num_disks=data.num_disks??1;this.disk_usable_size=data.disk_usable_size??20*Gi;}
raid_scale_factor(){const round_ndigits=2;const factor=Math.max(1.0,(this.num_disks-1)*this.per_scale_in_raid+1.0);return Math.round(factor*Math.pow(10,round_ndigits))/Math.pow(10,round_ndigits);}
single_perf(){const s_tput=Math.floor(this.throughput_spec*this.throughput_scale_factor);const s_iops=Math.floor(this.random_iops_spec*this.random_iops_scale_factor);return[s_tput,s_iops];}
perf(){const raid_sf=this.raid_scale_factor();const[s_tput,s_iops]=this.single_perf();return[Math.floor(s_tput*raid_sf),Math.floor(s_iops*raid_sf)];}
static iops_to_throughput(iops){return iops*DB_PAGE_SIZE/Mi;}
static throughput_to_iops(throughput){return throughput*Math.floor(Mi/DB_PAGE_SIZE);}}
class PG_TUNE_USR_KWARGS{constructor(options={}){this.user_max_connections=options.user_max_connections??0;this.cpu_to_connection_scale_ratio=options.cpu_to_connection_scale_ratio??4;this.superuser_reserved_connections_scale_ratio=options.superuser_reserved_connections_scale_ratio??1.5;this.single_memory_connection_overhead=options.single_memory_connection_overhead??(5*Mi);this.memory_connection_to_dedicated_os_ratio=options.memory_connection_to_dedicated_os_ratio??0.7;this.effective_cache_size_available_ratio=options.effective_cache_size_available_ratio??0.985;this.shared_buffers_ratio=options.shared_buffers_ratio??0.25;this.max_work_buffer_ratio=options.max_work_buffer_ratio??0.075;this.effective_connection_ratio=options.effective_connection_ratio??0.75;this.temp_buffers_ratio=options.temp_buffers_ratio??0.25;this.max_normal_memory_usage=options.max_normal_memory_usage??0.45;this.mem_pool_tuning_ratio=options.mem_pool_tuning_ratio??0.4;this.hash_mem_usage_level=options.hash_mem_usage_level??-5;this.mem_pool_parallel_estimate=options.mem_pool_parallel_estimate??true;this.max_query_length_in_bytes=options.max_query_length_in_bytes??(2*Ki);this.max_runtime_ms_to_log_slow_query=options.max_runtime_ms_to_log_slow_query??(2*K10);this.max_runtime_ratio_to_explain_slow_query=options.max_runtime_ratio_to_explain_slow_query??1.5;this.wal_segment_size=options.wal_segment_size??BASE_WAL_SEGMENT_SIZE;this.min_wal_size_ratio=options.min_wal_size_ratio??0.05;this.max_wal_size_ratio=options.max_wal_size_ratio??0.05;this.wal_keep_size_ratio=options.wal_keep_size_ratio??0.05;this.autovacuum_utilization_ratio=options.autovacuum_utilization_ratio??0.80;this.vacuum_safety_level=options.vacuum_safety_level??2;}}
class PG_TUNE_USR_OPTIONS{constructor(options={}){this.workload_type=options.workload_type??PG_WORKLOAD.HTAP;this.workload_profile=options.workload_profile??PG_SIZING.LARGE;this.pgsql_version=options.pgsql_version??17;this.operating_system=options.operating_system??'linux';this.vcpu=options.vcpu??4;this.total_ram=options.total_ram??(16*Gi);this.base_kernel_memory_usage=options.base_kernel_memory_usage??-1;this.base_monitoring_memory_usage=options.base_monitoring_memory_usage??-1;this.opt_mem_pool=options.opt_mem_pool??PG_PROFILE_OPTMODE.OPTIMUS_PRIME;this.data_index_spec=options.data_index_spec;this.wal_spec=options.wal_spec;this.max_backup_replication_tool=options.max_backup_replication_tool??PG_BACKUP_TOOL.PG_BASEBACKUP;this.opt_transaction_lost=options.opt_transaction_lost??PG_PROFILE_OPTMODE.NONE;this.opt_wal_buffers=options.opt_wal_buffers??PG_PROFILE_OPTMODE.SPIDEY;this.max_time_transaction_loss_allow_in_millisecond=options.max_time_transaction_loss_allow_in_millisecond??650;this.max_num_stream_replicas_on_primary=options.max_num_stream_replicas_on_primary??0;this.max_num_logical_replicas_on_primary=options.max_num_logical_replicas_on_primary??0;this.offshore_replication=options.offshore_replication??false;this.tuning_kwargs=options.tuning_kwargs??new PG_TUNE_USR_KWARGS();this.database_size_in_gib=options.database_size_in_gib??0;this.num_write_transaction_per_hour_on_workload=options.num_write_transaction_per_hour_on_workload??(50*K10);this.enable_database_general_tuning=options.enable_database_general_tuning??true;this.enable_database_correction_tuning=options.enable_database_correction_tuning??true;this.align_index=options.align_index??1;this.model_post_init();}
model_post_init(){if(!this.enable_database_general_tuning){this.enable_database_correction_tuning=false;}
if(this.base_monitoring_memory_usage===-1){this.base_monitoring_memory_usage=256*Mi;if(this.operating_system==='containerd'){this.base_monitoring_memory_usage=64*Mi;}else if(this.operating_system==='PaaS'){this.base_monitoring_memory_usage=0;}
console.debug(`Set the monitoring memory usage to ${bytesize_to_hr(this.base_monitoring_memory_usage, false, ' ')}`);}
if(this.base_kernel_memory_usage===-1){this.base_kernel_memory_usage=768*Mi;if(this.operating_system==='containerd'){this.base_kernel_memory_usage=64*Mi;}else if(this.operating_system==='windows'){this.base_kernel_memory_usage=2*Gi;}else if(this.operating_system==='PaaS'){this.base_kernel_memory_usage=0;}
console.debug(`Set the kernel memory usage to ${bytesize_to_hr(this.base_kernel_memory_usage, false, ' ')}`);}
this.usable_ram=this.total_ram-this.base_kernel_memory_usage-this.base_monitoring_memory_usage
if(this.usable_ram<4*Gi){const _sign=(this.usable_ram>=0)?'+':'-';const _msg=`The usable RAM ${_sign}${bytesize_to_hr(this.usable_ram, false, ' ')} is less than 4 GiB. Tuning may not be accurate.`;console.warn(_msg);}else{console.debug(`The usable RAM is ${bytesize_to_hr(this.usable_ram)}`);}
const _database_limit=Math.ceil((this.data_index_spec.disk_usable_size/Gi)*0.90);if(this.database_size_in_gib===0){console.warn('Database size is 0 GiB; estimating as 60% of data volume.');this.database_size_in_gib=Math.ceil((this.data_index_spec.disk_usable_size/Gi)*0.60);}
if(this.database_size_in_gib>_database_limit){console.warn(`Database size ${this.database_size_in_gib} GiB exceeds 90% of data volume; capping to ${_database_limit} GiB.`);this.database_size_in_gib=_database_limit;}
this.hardware_scope={'cpu':this.workload_profile,'mem':this.workload_profile,'net':this.workload_profile,'disk':this.workload_profile,'overall':this.workload_profile};}
translate_hardware_scope(term){if(term!==null){term=term.toLowerCase().trim();if(this.hardware_scope.hasOwnProperty(term)){return this.hardware_scope[term];}else{console.debug(`Hardware scope ${term} not supported -> falling back to overall profile.`);}}
return this.workload_profile;}}
const __BASE_RESERVED_DB_CONNECTION=3;const __DESCALE_FACTOR_RESERVED_DB_CONNECTION=4;function _GetNumConnections(options,response,use_reserved_connection=false,use_full_connection=false){let managed_cache=response.get_managed_cache(PGTUNER_SCOPE.DATABASE_CONFIG);try{let total_connections=managed_cache['max_connections'];let reserved_connections=managed_cache['reserved_connections']+managed_cache['superuser_reserved_connections'];if(!use_reserved_connection){total_connections-=reserved_connections;}else{console.debug(`The reserved mode is enabled (not recommended) as reserved connections are purposely 
                different usage such as troubleshooting, maintenance, **replication**, sharding, cluster, ...`)}
if(!use_full_connection){total_connections*=options.tuning_kwargs.effective_connection_ratio;}
return Math.ceil(total_connections);}catch(e){throw new Error("This function required the connection must be triggered and placed in the managed cache: "+e);}}
function _GetMemConnInTotal(options,response,use_reserved_connection=false,use_full_connection=false){let num_conns=_GetNumConnections(options,response,use_reserved_connection,use_full_connection);let mem_conn_overhead=options.tuning_kwargs.single_memory_connection_overhead;return Math.floor(num_conns*mem_conn_overhead);}
function _CalcSharedBuffers(options){let shared_buffers_ratio=options.tuning_kwargs.shared_buffers_ratio;if(shared_buffers_ratio<0.25){console.warn(`The shared_buffers_ratio is too low, which official PostgreSQL documentation recommended 
            the starting point is 25% of RAM or over. Please consider increasing the ratio.`);}
let shared_buffers=Math.max(options.usable_ram*shared_buffers_ratio,128*Mi);if(shared_buffers===128*Mi){console.warn('No benefit is found on tuning this variable');}
shared_buffers=realign_value(Math.floor(shared_buffers),DB_PAGE_SIZE)[options.align_index];console.debug(`shared_buffers: ${bytesize_to_hr(shared_buffers)}`);return shared_buffers;}
function _CalcTempBuffersAndWorkMem(group_cache,global_cache,options,response){let overhead=_GetMemConnInTotal(options,response,false,true)*options.tuning_kwargs.memory_connection_to_dedicated_os_ratio;let pgmem_available=options.usable_ram-group_cache['shared_buffers']-overhead;if('wal_buffers'in global_cache){pgmem_available-=global_cache['wal_buffers'];}
let max_work_buffer_ratio=options.tuning_kwargs.max_work_buffer_ratio;let active_connections=_GetNumConnections(options,response,false,false);let total_buffers=Math.floor(pgmem_available*max_work_buffer_ratio/active_connections);let max_cap=1.5*Gi;if(options.workload_type===PG_WORKLOAD.TSR_IOT){max_cap=256*Mi;}else if(options.workload_type===PG_WORKLOAD.HTAP||options.workload_type===PG_WORKLOAD.OLAP){max_cap=8*Gi;}
let temp_buffer_ratio=options.tuning_kwargs.temp_buffers_ratio;let temp_buffers=cap_value(total_buffers*temp_buffer_ratio,1*Mi,max_cap);let work_mem=cap_value(total_buffers*(1-temp_buffer_ratio),1*Mi,max_cap);temp_buffers=realign_value(Math.floor(temp_buffers),DB_PAGE_SIZE)[options.align_index];work_mem=realign_value(Math.floor(work_mem),DB_PAGE_SIZE)[options.align_index];console.debug(`temp_buffers: ${bytesize_to_hr(temp_buffers)}`);console.debug(`work_mem: ${bytesize_to_hr(work_mem)}`);return[temp_buffers,work_mem];}
function _CalcTempBuffers(group_cache,global_cache,options,response){return _CalcTempBuffersAndWorkMem(group_cache,global_cache,options,response)[0];}
function _CalcWorkMem(group_cache,global_cache,options,response){return _CalcTempBuffersAndWorkMem(group_cache,global_cache,options,response)[1];}
function _GetMaxConns(options,group_cache,min_user_conns,max_user_conns){let total_reserved_connections=group_cache['reserved_connections']+group_cache['superuser_reserved_connections'];if(options.tuning_kwargs.user_max_connections!==0){console.debug('The max_connections variable is overridden by the user so no constraint here.');const allowed_connections=options.tuning_kwargs.user_max_connections;return allowed_connections+total_reserved_connections;}
let _upscale=options.tuning_kwargs.cpu_to_connection_scale_ratio;console.debug(`The max_connections variable is determined by the number of logical CPU count with the scale factor of ${_upscale.toFixed(1)}x.`);let _minimum=Math.max(min_user_conns,total_reserved_connections);let max_connections=cap_value(Math.ceil(options.vcpu*_upscale),_minimum,max_user_conns)+total_reserved_connections;console.debug(`max_connections: ${max_connections}`);return max_connections;}
function _GetReservedConns(options,minimum,maximum,superuser_mode=false,base_reserved_connection=null){if(base_reserved_connection==null){base_reserved_connection=__BASE_RESERVED_DB_CONNECTION;}
let reserved_connections;let descale_factor;let superuser_descale_ratio;if(!superuser_mode){reserved_connections=options.vcpu/__DESCALE_FACTOR_RESERVED_DB_CONNECTION;}else{superuser_descale_ratio=options.tuning_kwargs.superuser_reserved_connections_scale_ratio;descale_factor=__DESCALE_FACTOR_RESERVED_DB_CONNECTION*superuser_descale_ratio;reserved_connections=options.vcpu/descale_factor;}
return cap_value(Math.floor(reserved_connections),minimum,maximum)+base_reserved_connection;}
function _CalcEffectiveCacheSize(group_cache,global_cache,options,response){let overhead=_GetMemConnInTotal(options,response,false,true)*options.tuning_kwargs.memory_connection_to_dedicated_os_ratio;let pgmem_available=Math.floor(options.usable_ram-global_cache['shared_buffers']-overhead);let effective_cache_size=pgmem_available*options.tuning_kwargs.effective_cache_size_available_ratio;effective_cache_size=realign_value(Math.floor(effective_cache_size),DB_PAGE_SIZE)[options.align_index];console.debug(`Effective cache size: ${bytesize_to_hr(effective_cache_size)}`);return effective_cache_size;}
function _CalcWalBuffers(group_cache,global_cache,options,response,minimum,maximum){let shared_buffers=global_cache['shared_buffers'];let usable_ram_noswap=options.usable_ram;function fn(x){return 1024*(37.25*Math.log(x)+2)*0.90;}
let oldstyle_wal_buffers=Math.min(Math.floor(shared_buffers/32),options.tuning_kwargs.wal_segment_size);let wal_buffers=Math.max(oldstyle_wal_buffers,fn(usable_ram_noswap/Gi)*Ki);return realign_value(cap_value(Math.ceil(wal_buffers),minimum,maximum),DB_PAGE_SIZE)[options.align_index];}
_DB_CONN_PROFILE={'superuser_reserved_connections':{'instructions':{'mini':(group_cache,global_cache,options,response)=>_GetReservedConns(options,0,3,true,1),'medium':(group_cache,global_cache,options,response)=>_GetReservedConns(options,0,5,true,2),},'tune_op':(group_cache,global_cache,options,response)=>_GetReservedConns(options,0,10,true),'default':__BASE_RESERVED_DB_CONNECTION,},'reserved_connections':{'instructions':{'mini':(group_cache,global_cache,options,response)=>_GetReservedConns(options,0,3,false,1),'medium':(group_cache,global_cache,options,response)=>_GetReservedConns(options,0,5,false,2),},'tune_op':(group_cache,global_cache,options,response)=>_GetReservedConns(options,0,10,false),'default':__BASE_RESERVED_DB_CONNECTION,},'max_connections':{'instructions':{'mini':(group_cache,global_cache,options,response)=>_GetMaxConns(options,group_cache,10,30),'medium':(group_cache,global_cache,options,response)=>_GetMaxConns(options,group_cache,15,65),'large':(group_cache,global_cache,options,response)=>_GetMaxConns(options,group_cache,20,100),'mall':(group_cache,global_cache,options,response)=>_GetMaxConns(options,group_cache,25,175),'bigt':(group_cache,global_cache,options,response)=>_GetMaxConns(options,group_cache,30,250),},'default':30,},'listen_addresses':{'default':'*',}}
_DB_RESOURCE_PROFILE={'shared_buffers':{'tune_op':(group_cache,global_cache,options,response)=>_CalcSharedBuffers(options),'default':128*Mi,'partial_func':(value)=>`${Math.floor(value / Mi)}MB`,},'temp_buffers':{'tune_op':(group_cache,global_cache,options,response)=>_CalcTempBuffers(group_cache,global_cache,options,response),'default':8*Mi,'partial_func':(value)=>`${Math.floor(value / DB_PAGE_SIZE) * Math.floor(DB_PAGE_SIZE / Ki)}kB`,},'work_mem':{'tune_op':(group_cache,global_cache,options,response)=>_CalcWorkMem(group_cache,global_cache,options,response),'default':4*Mi,'partial_func':(value)=>`${Math.floor(value / DB_PAGE_SIZE) * Math.floor(DB_PAGE_SIZE / Ki)}kB`,},'hash_mem_multiplier':{'default':2.0,},}
_DB_VACUUM_PROFILE={'autovacuum':{'default':'on',},'autovacuum_max_workers':{'instructions':{'mini_default':1,'medium_default':2,'large':(group_cache,global_cache,options,response)=>cap_value(Math.floor(options.vcpu/4)+1,2,5),'mall':(group_cache,global_cache,options,response)=>cap_value(Math.floor(options.vcpu/3.5)+1,3,6),'bigt':(group_cache,global_cache,options,response)=>cap_value(Math.floor(options.vcpu/3)+1,3,8),},'default':3,'hardware_scope':'cpu',},'autovacuum_naptime':{'tune_op':(group_cache,global_cache,options,response)=>SECOND*(15+30*(group_cache['autovacuum_max_workers']-1)),'default':1*MINUTE,'partial_func':(value)=>`${Math.floor(value / SECOND)}s`,},'maintenance_work_mem':{'tune_op':(group_cache,global_cache,options,response)=>realign_value(cap_value(Math.floor((options.usable_ram-global_cache['shared_buffers'])/10),64*Mi,8*Gi),Ki)[options.align_index],'default':64*Mi,'post-condition-group':(value,cache,options)=>value*cache['autovacuum_max_workers']<Math.floor(options.usable_ram/2),'partial_func':(value)=>`${Math.floor(value / Mi)}MB`,},'autovacuum_work_mem':{'default':-1,},'autovacuum_vacuum_threshold; autovacuum_vacuum_insert_threshold; autovacuum_analyze_threshold':{'instructions':{'mini_default':Math.floor(K10/2),},'hardware_scope':'overall','default':2*K10,},'autovacuum_vacuum_scale_factor; autovacuum_vacuum_insert_scale_factor; autovacuum_analyze_scale_factor':{'instructions':{'mini_default':0.010,'mall_default':0.002,'bigt_default':0.002,},'hardware_scope':'overall','default':0.005,},'autovacuum_vacuum_cost_delay':{'default':2,'partial_func':(value)=>`${value}ms`,},'autovacuum_vacuum_cost_limit':{'default':-1,},'vacuum_cost_delay':{'default':0,'partial_func':(value)=>`${value}ms`,},'vacuum_cost_limit':{'instructions':{'large_default':500,'mall_default':K10,'bigt_default':K10,},'default':200,},'vacuum_cost_page_hit':{'default':1,},'vacuum_cost_page_miss':{'default':2,},'vacuum_cost_page_dirty':{'default':20,},'autovacuum_freeze_max_age':{'default':500*M10,},'vacuum_freeze_table_age':{'tune_op':(group_cache,global_cache,options,response)=>realign_value(Math.ceil(group_cache['autovacuum_freeze_max_age']*0.85),250*K10)[options.align_index],'default':150*M10,},'vacuum_freeze_min_age':{'default':50*M10,},'autovacuum_multixact_freeze_max_age':{'default':850*M10,},'vacuum_multixact_freeze_table_age':{'tune_op':(group_cache,global_cache,options,response)=>realign_value(Math.ceil(group_cache['autovacuum_multixact_freeze_max_age']*0.85),250*K10)[options.align_index],'default':150*M10,},'vacuum_multixact_freeze_min_age':{'default':5*M10,},}
_DB_BGWRITER_PROFILE={'bgwriter_delay':{'default':300,'hardware_scope':'overall','partial_func':(value)=>`${value}ms`,},'bgwriter_lru_maxpages':{'instructions':{'large_default':350,'mall_default':425,'bigt_default':500,},'default':300,},'bgwriter_lru_multiplier':{'default':2.0,},'bgwriter_flush_after':{'default':512*Ki,'partial_func':(value)=>`${Math.floor(value / Ki)}kB`,},}
_DB_ASYNC_DISK_PROFILE={'effective_io_concurrency':{'default':16,},'maintenance_io_concurrency':{'default':10,},'backend_flush_after':{'default':0,},}
_DB_ASYNC_CPU_PROFILE={'max_worker_processes':{'tune_op':(group_cache,global_cache,options,response)=>cap_value(Math.ceil(options.vcpu*1.5)+2,4,512),'default':8,},'max_parallel_workers':{'tune_op':(group_cache,global_cache,options,response)=>Math.min(cap_value(Math.ceil(options.vcpu*1.25)+1,4,512),group_cache['max_worker_processes']),'default':8,},'max_parallel_workers_per_gather':{'tune_op':(group_cache,global_cache,options,response)=>Math.min(cap_value(Math.ceil(options.vcpu/2.5),2,32),group_cache['max_parallel_workers']),'default':2,},'max_parallel_maintenance_workers':{'tune_op':(group_cache,global_cache,options,response)=>Math.min(cap_value(Math.ceil(options.vcpu/2),2,32),group_cache['max_parallel_workers']),'default':2,},'min_parallel_table_scan_size':{'instructions':{'medium_default':16*Mi,'large_default':24*Mi,'mall_default':32*Mi,'bigt_default':32*Mi,},'default':8*Mi,'partial_func':(value)=>`${Math.floor(value / DB_PAGE_SIZE) * Math.floor(DB_PAGE_SIZE / Ki)}kB`,},'min_parallel_index_scan_size':{'tune_op':(group_cache,global_cache,options,response)=>Math.max(group_cache['min_parallel_table_scan_size']/16,512*Ki),'default':512*Ki,'partial_func':(value)=>`${Math.floor(value / DB_PAGE_SIZE) * Math.floor(DB_PAGE_SIZE / Ki)}kB`,},}
_DB_WAL_PROFILE={'wal_level':{'default':'replica',},'synchronous_commit':{'default':'on',},'full_page_writes':{'default':'on',},'fsync':{'default':'on',},'wal_compression':{'default':'pglz',},'wal_init_zero':{'default':'on',},'wal_recycle':{'default':'on',},'wal_log_hints':{'default':'on',},'wal_writer_delay':{'instructions':{"mini_default":K10,},'default':200,'partial_func':(value)=>`${value}ms`,},'wal_writer_flush_after':{'default':1*Mi,'partial_func':(value)=>`${Math.floor(value / Mi)}MB`,},'checkpoint_timeout':{'instructions':{'mini_default':30*MINUTE,'mall_default':10*MINUTE,'bigt_default':10*MINUTE,},'default':15*MINUTE,'hardware_scope':'overall','partial_func':(value)=>`${Math.floor(value / MINUTE)}min`,},'checkpoint_flush_after':{'default':256*Ki,'partial_func':(value)=>`${Math.floor(value / Ki)}kB`,},'checkpoint_completion_target':{'default':0.9,},'checkpoint_warning':{'default':30,'partial_func':(value)=>`${value}s`,},'min_wal_size':{'tune_op':(group_cache,global_cache,options,response)=>10*options.tuning_kwargs.wal_segment_size,'default':10*BASE_WAL_SEGMENT_SIZE,'partial_func':(value)=>`${Math.floor(value / Mi)}MB`,},'max_wal_size':{'instructions':{'mini_default':2*Gi,'medium_default':4*Gi,'large_default':8*Gi,'mall_default':16*Gi,'bigt_default':32*Gi,},'default':8*Gi,'partial_func':(value)=>`${Math.floor(value / Mi)}MB`,},'wal_buffers':{'tune_op':(group_cache,global_cache,options,response)=>_CalcWalBuffers(group_cache,global_cache,options,response,Math.floor(BASE_WAL_SEGMENT_SIZE/2),BASE_WAL_SEGMENT_SIZE*16),'default':2*BASE_WAL_SEGMENT_SIZE,'hardware_scope':'mem','partial_func':(value)=>`${Math.floor(value / DB_PAGE_SIZE) * Math.floor(DB_PAGE_SIZE / Ki)}kB`,},'archive_mode':{'default':'on',},'archive_timeout':{'instructions':{'mini_default':1*HOUR,'mall_default':30*MINUTE,'bigt_default':30*MINUTE,},'default':45*MINUTE,'hardware_scope':'overall','partial_func':(value)=>`${value}s`,},}
_DB_RECOVERY_PROFILE={'recovery_end_command':{'default':'pg_ctl stop -D $PGDATA',},}
_DB_REPLICATION_PROFILE={'max_wal_senders':{'default':3,'hardware_scope':'net',},'max_replication_slots':{'default':3,'hardware_scope':'net',},'wal_keep_size':{'default':25*BASE_WAL_SEGMENT_SIZE,'partial_func':(value)=>`${Math.floor(value / Mi)}MB`,},'max_slot_wal_keep_size':{'default':-1,},'wal_sender_timeout':{'instructions':{'mall_default':2*MINUTE,'bigt_default':2*MINUTE,},'default':MINUTE,'hardware_scope':'net','partial_func':(value)=>`${value}s`,},'track_commit_timestamp':{'default':'on',},'logical_decoding_work_mem':{'tune_op':(group_cache,global_cache,options,response)=>realign_value(cap_value(Math.floor(group_cache['maintenance_work_mem']/8),32*Mi,2*Gi),DB_PAGE_SIZE)[options.align_index],'default':64*Mi,},}
_DB_QUERY_PROFILE={'seq_page_cost':{'default':1.0,},'random_page_cost':{'default':2.60,},'cpu_tuple_cost':{'default':0.03,},'cpu_index_tuple_cost':{'default':0.005,},'cpu_operator_cost':{'default':0.001,},'effective_cache_size':{'tune_op':_CalcEffectiveCacheSize,'default':4*Gi,'partial_func':(value)=>`${Math.floor(value / Mi)}MB`,},'default_statistics_target':{'instructions':{'large_default':300,'mall_default':400,'bigt_default':500,},'default':100,},'join_collapse_limit':{'instructions':{'large_default':12,'mall_default':16,'bigt_default':20,},'default':8,},'from_collapse_limit':{'instructions':{'large_default':12,'mall_default':16,'bigt_default':20,},'default':8,},'plan_cache_mode':{'default':'auto',},'parallel_setup_cost':{'instructions':{'mall_default':750,"bigt_default":500,},'default':1000,},'parallel_tuple_cost':{'tune_op':(group_cache,global_cache,options,response)=>(group_cache['cpu_tuple_cost']*8+0.1)/2,'default':0.1,},'commit_delay':{'instructions':{'large_default':500,'mall_default':500,'bigt_default':200,},'default':1*K10,'hardware_scope':'overall',},'commit_siblings':{'instructions':{"large_default":8,"mall_default":10,"bigt_default":10,},'default':5,'hardware_scope':'overall',},'track_activity_query_size':{'default':2*Ki,'partial_func':(value)=>`${value}B`,},'track_counts':{'default':'on',},'track_io_timing':{'default':'on','hardware_scope':'cpu',},}
_DB_LOG_PROFILE={'logging_collector':{'default':'on',},'log_destination':{'default':'stderr',},'log_directory':{'default':'log',},'log_filename':{'default':'postgresql-%Y-%m-%d_%H%M.log',},'log_rotation_age':{'instructions':{'mini_default':3*DAY,'mall_default':6*HOUR,'bigt_default':4*HOUR,},'default':1*DAY,'partial_func':(value)=>`${Math.floor(value / HOUR)}h`,},'log_rotation_size':{'instructions':{'mini_default':32*Mi,'medium_default':64*Mi,},'default':256*Mi,'partial_func':(value)=>`${Math.floor(value / Mi)}MB`,},'log_truncate_on_rotation':{'default':'on',},'log_autovacuum_min_duration':{'default':300*K10,'partial_func':(value)=>`${Math.floor(value / K10)}s`,},'log_checkpoints':{'default':'on',},'log_connections':{'default':'on',},'log_disconnections':{'default':'on',},'log_duration':{'default':'on',},'log_error_verbosity':{'default':'VERBOSE',},'log_line_prefix':{'default':'%m [%p] %quser=%u@%r@%a_db=%d,backend=%b,xid=%x %v,log=%l',},'log_lock_waits':{'default':'on',},'log_recovery_conflict_waits':{'default':'on',},'log_statement':{'default':'mod',},'log_replication_commands':{'default':'on',},'log_min_duration_statement':{'default':2*K10,'partial_func':(value)=>`${value}ms`,},'log_min_error_statement':{'default':'ERROR',},'log_parameter_max_length':{'tune_op':(group_cache,global_cache,options,response)=>global_cache['track_activity_query_size'],'default':-1,'partial_func':(value)=>`${value}B`,},'log_parameter_max_length_on_error':{'tune_op':(group_cache,global_cache,options,response)=>global_cache['track_activity_query_size'],'default':-1,'partial_func':(value)=>`${value}B`,},}
_DB_TIMEOUT_PROFILE={'idle_in_transaction_session_timeout':{'default':5*MINUTE+1,'partial_func':(value)=>`${value}s`,},'statement_timeout':{'default':0,'partial_func':(value)=>`${value}s`,},'lock_timeout':{'default':0,'partial_func':(value)=>`${value}s`,},'deadlock_timeout':{'default':1*SECOND,'partial_func':(value)=>`${value}s`,},}
_DB_LIB_PROFILE={'shared_preload_libraries':{'default':'auto_explain,pg_prewarm,pgstattuple,pg_stat_statements,pg_buffercache,pg_visibility',},'auto_explain.log_min_duration':{'tune_op':(group_cache,global_cache,options,response)=>realign_value(Math.floor(global_cache['log_min_duration_statement']*3/2),20)[options.align_index],'default':-1,'partial_func':(value)=>`${value}ms`,},'auto_explain.log_analyze':{'default':'off',},'auto_explain.log_buffers':{'default':'on',},'auto_explain.log_wal':{'default':'on',},'auto_explain.log_settings':{'default':'off',},'auto_explain.log_triggers':{'default':'off',},'auto_explain.log_verbose':{'default':'on',},'auto_explain.log_format':{'default':'text',},'auto_explain.log_level':{'default':'LOG',},'auto_explain.log_timing':{'default':'on',},'auto_explain.log_nested_statements':{'default':'off',},'auto_explain.sample_rate':{'default':1.0,},'pg_stat_statements.max':{'instructions':{'large_default':10*K10,'mall_default':15*K10,'bigt_default':20*K10,},'default':5*K10,},'pg_stat_statements.track':{'default':'all',},'pg_stat_statements.track_utility':{'default':'on',},'pg_stat_statements.track_planning':{'default':'off',},'pg_stat_statements.save':{'default':'on',},}
const preload_libraries=new Set(_DB_LIB_PROFILE['shared_preload_libraries']['default'].split(','));for(const key of Object.keys(_DB_LIB_PROFILE)){if(key.includes('.')&&!preload_libraries.has(key.split('.')[0])){delete _DB_LIB_PROFILE[key];}}
const DB0_CONFIG_PROFILE={"connection":[PG_SCOPE.CONNECTION,_DB_CONN_PROFILE,{hardware_scope:'cpu'}],"memory":[PG_SCOPE.MEMORY,_DB_RESOURCE_PROFILE,{hardware_scope:'mem'}],"maintenance":[PG_SCOPE.MAINTENANCE,_DB_VACUUM_PROFILE,{hardware_scope:'overall'}],"background_writer":[PG_SCOPE.OTHERS,_DB_BGWRITER_PROFILE,{hardware_scope:'disk'}],"asynchronous_disk":[PG_SCOPE.OTHERS,_DB_ASYNC_DISK_PROFILE,{hardware_scope:'disk'}],"asynchronous_cpu":[PG_SCOPE.OTHERS,_DB_ASYNC_CPU_PROFILE,{hardware_scope:'cpu'}],"wal":[PG_SCOPE.ARCHIVE_RECOVERY_BACKUP_RESTORE,_DB_WAL_PROFILE,{hardware_scope:'disk'}],"query":[PG_SCOPE.QUERY_TUNING,_DB_QUERY_PROFILE,{hardware_scope:'cpu'}],"log":[PG_SCOPE.LOGGING,_DB_LOG_PROFILE,{hardware_scope:'disk'}],"replication":[PG_SCOPE.ARCHIVE_RECOVERY_BACKUP_RESTORE,_DB_REPLICATION_PROFILE,{hardware_scope:'disk'}],"timeout":[PG_SCOPE.OTHERS,_DB_TIMEOUT_PROFILE,{hardware_scope:'overall'}],"lib":[PG_SCOPE.EXTRA,_DB_LIB_PROFILE,{hardware_scope:'overall'}],};merge_extra_info_to_profile(DB0_CONFIG_PROFILE);type_validation(DB0_CONFIG_PROFILE);const DB13_CONFIG_PROFILE={...DB0_CONFIG_PROFILE};const _DB14_TIMEOUT_PROFILE={'idle_session_timeout':{"default":0,"partial_func":value=>`${value}s`,},};const _DB14_QUERY_PROFILE={'track_wal_io_timing':{"default":'on',},};const _DB14_VACUUM_PROFILE={'vacuum_failsafe_age':{"default":1600000000,},'vacuum_multixact_failsafe_age':{"default":1600000000,}};const DB14_CONFIG_MAPPING={timeout:[PG_SCOPE.OTHERS,_DB14_TIMEOUT_PROFILE,{hardware_scope:'overall'}],query:[PG_SCOPE.QUERY_TUNING,_DB14_QUERY_PROFILE,{hardware_scope:'overall'}],maintenance:[PG_SCOPE.MAINTENANCE,_DB14_VACUUM_PROFILE,{hardware_scope:'overall'}],};merge_extra_info_to_profile(DB14_CONFIG_MAPPING);type_validation(DB14_CONFIG_MAPPING);let DB14_CONFIG_PROFILE={...DB13_CONFIG_PROFILE};if(Object.keys(DB14_CONFIG_MAPPING).length>0){for(const[key,value]of Object.entries(DB14_CONFIG_MAPPING)){if(key in DB14_CONFIG_PROFILE){let src=DB14_CONFIG_PROFILE[key][1];let dst=value[1];for(const[k,v]of Object.entries(dst)){src[k]=v;}}}
rewrite_items(DB14_CONFIG_PROFILE);}
const _DB15_LOG_PROFILE={"log_startup_progress_interval":{"default":K10,"partial_func":value=>`${value}s`,},};const DB15_CONFIG_MAPPING={log:[PG_SCOPE.LOGGING,_DB15_LOG_PROFILE,{hardware_scope:'disk'}],};merge_extra_info_to_profile(DB15_CONFIG_MAPPING);type_validation(DB15_CONFIG_MAPPING);let DB15_CONFIG_PROFILE={...DB14_CONFIG_PROFILE};if(Object.keys(DB15_CONFIG_MAPPING).length>0){for(const[key,value]of Object.entries(DB15_CONFIG_MAPPING)){if(key in DB15_CONFIG_PROFILE){let src=DB15_CONFIG_PROFILE[key][1];let dst=value[1];for(const[k,v]of Object.entries(dst)){src[k]=v;}}}
rewrite_items(DB15_CONFIG_PROFILE);}
const _DB16_VACUUM_PROFILE={'vacuum_buffer_usage_limit':{"tune_op":(group_cache,global_cache,options,response)=>realign_value(cap_value(Math.floor(group_cache['shared_buffers']/16),2*Mi,16*Gi),DB_PAGE_SIZE)[options.align_index],"default":2*Mi,"hardware_scope":"mem","partial_func":value=>`${Math.floor(value / Mi)}MB`,},};const _DB16_WAL_PROFILE={"wal_compression":{"default":"zstd",},};const DB16_CONFIG_MAPPING={maintenance:[PG_SCOPE.MAINTENANCE,_DB16_VACUUM_PROFILE,{hardware_scope:'overall'}],wal:[PG_SCOPE.ARCHIVE_RECOVERY_BACKUP_RESTORE,_DB16_WAL_PROFILE,{hardware_scope:'disk'}],};merge_extra_info_to_profile(DB16_CONFIG_MAPPING);type_validation(DB16_CONFIG_MAPPING);let DB16_CONFIG_PROFILE={...DB15_CONFIG_PROFILE}
if(Object.keys(DB16_CONFIG_MAPPING).length>0){for(const[key,value]of Object.entries(DB16_CONFIG_MAPPING)){if(key in DB16_CONFIG_PROFILE){let src=DB16_CONFIG_PROFILE[key][1];let dst=value[1];for(const[k,v]of Object.entries(dst)){src[k]=v;}}}
rewrite_items(DB16_CONFIG_PROFILE);}
const _DB17_WAL_PROFILE={"summarize_wal":{"default":"on",},"wal_summary_keep_time":{"default":Math.floor(30*DAY/MINUTE),"partial_func":value=>`${Math.floor(value / MINUTE)}min`,},};const _DB17_TIMEOUT_PROFILE={"idle_session_timeout":{"default":0,"partial_func":value=>`${value}s`,},"transaction_timeout":{"default":0,"partial_func":value=>`${value}s`,},};const _DB17_ASYNC_DISK_PROFILE={"io_combine_limit":{"default":128*Ki,"partial_func":value=>`${Math.floor(value / DB_PAGE_SIZE) * Math.floor(DB_PAGE_SIZE / Ki)}kB`,},};const DB17_CONFIG_MAPPING={timeout:[PG_SCOPE.OTHERS,_DB17_TIMEOUT_PROFILE,{hardware_scope:'overall'}],wal:[PG_SCOPE.ARCHIVE_RECOVERY_BACKUP_RESTORE,_DB17_WAL_PROFILE,{hardware_scope:'overall'}],"asynchronous_disk":[PG_SCOPE.OTHERS,_DB17_ASYNC_DISK_PROFILE,{hardware_scope:'disk'}],};merge_extra_info_to_profile(DB17_CONFIG_MAPPING);type_validation(DB17_CONFIG_MAPPING);let DB17_CONFIG_PROFILE={...DB16_CONFIG_PROFILE}
if(Object.keys(DB17_CONFIG_MAPPING).length>0){for(const[key,value]of Object.entries(DB17_CONFIG_MAPPING)){if(key in DB17_CONFIG_PROFILE){let src=DB17_CONFIG_PROFILE[key][1];let dst=value[1];for(const[k,v]of Object.entries(dst)){src[k]=v;}}}
rewrite_items(DB17_CONFIG_PROFILE);}
const _DB18_ASYNC_DISK_PROFILE={"io_max_combine_limit":{"default":128*Ki,"partial_func":value=>`${Math.floor(value / DB_PAGE_SIZE) * Math.floor(DB_PAGE_SIZE / Ki)}kB`,},"io_max_concurrency":{"default":cap_value(-1,-1,1024)},"io_method":{"default":"io_uring",},"io_workers":{"default":cap_value(3,1,32),},};const _DB18_VACUUM_PROFILE={"autovacuum_vacuum_max_threshold":{"default":cap_value(100*M10,-1,2**31-1)},"autovacuum_worker_slots":{"default":cap_value(16,-1,2**18-1)},"vacuum_max_eager_freeze_failure_rate":{"default":cap_value(0.03,0.0,1.0)},"vacuum_truncate":{"default":'on'},};const _DB18_QUERY_PROFILE={"track_cost_delay_timing":{"default":'on',}};const _DB18_LOG_PROFILE={"log_lock_failure":{"default":'on',}};const _DB18_TIMEOUT_PROFILE={"idle_replication_slot_timeout":{"default":cap_value(0,0,35791394)},};const _DB18_REPLICATION_PROFILE={"max_active_replication_origins":{"default":cap_value(10,0,2**18-1)},};const DB18_CONFIG_MAPPING={"asynchronous_disk":[PG_SCOPE.OTHERS,_DB18_ASYNC_DISK_PROFILE,{hardware_scope:'disk'}],maintenance:[PG_SCOPE.MAINTENANCE,_DB18_VACUUM_PROFILE,{'hardware_scope':'overall'}],query:[PG_SCOPE.QUERY_TUNING,_DB18_QUERY_PROFILE,{hardware_scope:'overall'}],log:[PG_SCOPE.LOGGING,_DB18_LOG_PROFILE,{hardware_scope:'disk'}],timeout:[PG_SCOPE.OTHERS,_DB18_TIMEOUT_PROFILE,{hardware_scope:'overall'}],replication:[PG_SCOPE.ARCHIVE_RECOVERY_BACKUP_RESTORE,_DB18_REPLICATION_PROFILE,{hardware_scope:'cpu'}],};merge_extra_info_to_profile(DB18_CONFIG_MAPPING);type_validation(DB18_CONFIG_MAPPING);let DB18_CONFIG_PROFILE={...DB17_CONFIG_PROFILE}
if(Object.keys(DB18_CONFIG_MAPPING).length>0){for(const[key,value]of Object.entries(DB18_CONFIG_MAPPING)){if(key in DB18_CONFIG_PROFILE){let src=DB18_CONFIG_PROFILE[key][1];let dst=value[1];for(const[k,v]of Object.entries(dst)){src[k]=v;}}}
rewrite_items(DB18_CONFIG_PROFILE);}
const _FILE_ROTATION_TIME_MS=0.21*2
const _DISK_ZERO_SPEED=2.9*Ki
function wal_time(wal_buffers,data_amount_ratio,wal_segment_size,wal_writer_delay_in_ms,wal_throughput,options,wal_init_zero){console.debug('Estimate the time required to flush the full WAL buffers to disk');const data_amount=Math.floor(wal_buffers*data_amount_ratio);const num_wal_files_required=Math.floor(data_amount/wal_segment_size)+1;let rotate_time_in_ms=num_wal_files_required*_FILE_ROTATION_TIME_MS;const write_time_in_ms=(data_amount/Mi)/wal_throughput*K10;if(wal_init_zero==='on'&&options.operating_system!=='windows'){rotate_time_in_ms+=num_wal_files_required*((wal_segment_size/Mi)/_DISK_ZERO_SPEED*K10);}
let delay_time=0;if(data_amount_ratio>1){let num_delay=Math.floor(data_amount_ratio);const fractional=data_amount_ratio-num_delay;if(fractional===0){num_delay-=1;}
delay_time=num_delay*wal_writer_delay_in_ms;}
const total_time=rotate_time_in_ms+write_time_in_ms+delay_time;const msg=`Estimate the time required to flush the full-queued WAL buffers ${bytesize_to_hr(data_amount)} to disk: rotation time: ${rotate_time_in_ms.toFixed(2)} ms, write time: ${write_time_in_ms.toFixed(2)} ms, delay time: ${delay_time.toFixed(2)} ms --> Total: ${total_time.toFixed(2)} ms with ${num_wal_files_required} WAL files.`;return{'num_wal_files':num_wal_files_required,'rotate_time':rotate_time_in_ms,'write_time':write_time_in_ms,'delay_time':delay_time,'total_time':total_time,'msg':msg};}
function checkpoint_time(checkpoint_timeout_second,checkpoint_completion_target,shared_buffers,shared_buffers_ratio,effective_cache_size,max_wal_size,data_disk_iops){console.debug('Estimate the time required to flush the full WAL buffers to disk');const checkpoint_duration=Math.ceil(checkpoint_timeout_second*checkpoint_completion_target);const data_tran_tput=PG_DISK_PERF.iops_to_throughput(data_disk_iops)
const data_max_mib_written=data_tran_tput*checkpoint_duration;let data_amount=Math.floor(shared_buffers*shared_buffers_ratio);data_amount=Math.min(data_amount,effective_cache_size,max_wal_size);const page_amount=Math.floor(data_amount/DB_PAGE_SIZE);const data_write_time=Math.floor((data_amount/Mi)/data_tran_tput);const data_disk_utilization=data_write_time/checkpoint_duration;return{'checkpoint_duration':checkpoint_duration,'data_disk_translated_tput':data_tran_tput,'data_disk_max_mib_written':data_max_mib_written,'data_amount':data_amount,'page_amount':page_amount,'data_write_time':data_write_time,'data_disk_utilization':data_disk_utilization,}}
function vacuum_time(hit_cost,miss_cost,dirty_cost,delay_ms,cost_limit,data_disk_iops){console.debug('Estimate the time required to vacuum the dirty pages');const budget_per_sec=Math.ceil(cost_limit/delay_ms*K10);const max_num_hit_page=Math.floor(budget_per_sec/hit_cost);const max_num_miss_page=Math.floor(budget_per_sec/miss_cost);const max_num_dirty_page=Math.floor(budget_per_sec/dirty_cost);const max_hit_data=PG_DISK_PERF.iops_to_throughput(max_num_hit_page);const max_miss_data=PG_DISK_PERF.iops_to_throughput(max_num_miss_page);const max_dirty_data=PG_DISK_PERF.iops_to_throughput(max_num_dirty_page);const _disk_tput=PG_DISK_PERF.iops_to_throughput(data_disk_iops);const _msg=`Reporting the time spent for normal vacuuming with the cost budget of ${budget_per_sec} in 1 second. 
HIT (page in shared_buffers): ${max_num_hit_page} page -> Throughput: ${max_hit_data.toFixed(2)} MiB/s -> Safe to GO: ${max_hit_data < 10 * K10} (< 10 GiB/s for low DDR3)
MISS (page in disk cache): ${max_num_miss_page} page -> Throughput: ${max_miss_data.toFixed(2)} MiB/s -> Safe to GO: ${max_miss_data < 5 * K10} (< 5 GiB/s for low DDR3)
DIRTY (page in disk): ${max_num_dirty_page} page -> Throughput: ${max_dirty_data.toFixed(2)} MiB/s -> Safe to GO: ${max_dirty_data < _disk_tput} (< Data Disk IOPS)`;const _551page=Math.floor(budget_per_sec/(5*hit_cost+5*miss_cost+dirty_cost));const _551data=PG_DISK_PERF.iops_to_throughput(_551page*5+_551page);const _111page=Math.floor(budget_per_sec/(hit_cost+miss_cost+dirty_cost));const _111data=PG_DISK_PERF.iops_to_throughput(_111page*1+_111page);return{max_num_hit_page:max_num_hit_page,max_num_miss_page:max_num_miss_page,max_num_dirty_page:max_num_dirty_page,max_hit_data:max_hit_data,max_miss_data:max_miss_data,max_dirty_data:max_dirty_data,'5:5:1_page':_551page,'5:5:1_data':_551data,'1:1:1_page':_111page,'1:1:1_data':_111data,msg:_msg}}
function vacuum_scale(threshold,scale_factor){console.debug('Estimate the number of changed or dead tuples to trigger normal vacuum');const _fn=(num_rows)=>Math.floor(threshold+scale_factor*num_rows);const dead_at_10k=_fn(10_000);const dead_at_300k=_fn(300_000);const dead_at_10m=_fn(10_000_000);const dead_at_100m=_fn(100_000_000);const dead_at_1b=_fn(1_000_000_000);const dead_at_10b=_fn(10_000_000_000);const msg=`The threshold of ${threshold} will trigger the normal vacuum when the number of changed or dead tuples exceeds ${threshold * scale_factor} tuples.
-> Table Size: 10K rows -> Dead Tuples: ${dead_at_10k} tuples
-> Table Size: 300K rows -> Dead Tuples: ${dead_at_300k} tuples
-> Table Size: 10M rows -> Dead Tuples: ${dead_at_10m} tuples
-> Table Size: 100M rows -> Dead Tuples: ${dead_at_100m} tuples
-> Table Size: 1B rows -> Dead Tuples: ${dead_at_1b} tuples
-> Table Size: 10B rows -> Dead Tuples: ${dead_at_10b} tuples`;return{'10k':dead_at_10k,'300k':dead_at_300k,'10m':dead_at_10m,'100m':dead_at_100m,'1b':dead_at_1b,'10b':dead_at_10b,msg:msg}}
class PG_TUNE_REQUEST{constructor(options){this.options=options.options;this.include_comment=options.include_comment??false;this.custom_style=options.custom_style??false;this.backup_settings=options.backup_settings??true;this.analyze_with_full_connection_use=options.analyze_with_full_connection_use??true;this.ignore_non_performance_setting=options.ignore_non_performance_setting??false;this.output_format=options.output_format??'file';}}
class PG_TUNE_RESPONSE{constructor(){this.outcome={}
this.outcome_cache={}
this.outcome[PGTUNER_SCOPE.DATABASE_CONFIG]={};this.outcome_cache[PGTUNER_SCOPE.DATABASE_CONFIG]={};}
get_managed_items(target,scope){if(!this.outcome.hasOwnProperty(target)){this.outcome[target]={};}
if(!this.outcome[target].hasOwnProperty(scope)){this.outcome[target][scope]={};}
return this.outcome[target][scope];}
get_managed_cache(target){if(!this.outcome_cache.hasOwnProperty(target)){this.outcome_cache[target]={};}
return this.outcome_cache[target];}
_file_config(target,request,exclude_names=null){let content=[target.disclaimer(),'\n'];if(request.backup_settings===true){content.push(`# User Options: ${JSON.stringify(request.options)}\n`);}
let custom_style=!request.custom_style?null:'ALTER SYSTEM SET $1 = $2;';for(const[scope,items]of Object.entries(this.outcome[target])){content.push(`## ===== SCOPE: ${scope} ===== \n`);for(const[item_name,item]of Object.entries(items)){if(exclude_names===null||!exclude_names.has(item_name)){content.push(item.out(request.include_comment,custom_style));content.push(request.include_comment?'\n\n':'\n');}}
content.push(request.include_comment?'\n\n':'\n');}
return content.join('');}
_response_config(target,request,exclude_names=null){let content={};for(const[_,items]of Object.entries(this.outcome[target])){for(const[item_name,item]of Object.entries(items)){if(exclude_names===null||!exclude_names.has(item_name)){content[item_name]=item.out_display(null);}}}
if(request.output_format==='conf'){return Object.entries(content).map(([k,v])=>`${k} = ${v}`).join('\n');}
return content;}
generate_content(target,request,exclude_names=null){if(exclude_names!==null&&Array.isArray(exclude_names)){exclude_names=new Set(exclude_names);}
if(request.output_format==='file'){return this._file_config(target,request,exclude_names);}else if(['json','conf'].includes(request.output_format)){return this._response_config(target,request,exclude_names);}else{throw new Error(`Invalid output format: ${request.output_format}. Expected one of "json", "conf", "file".`);}}
report(options,use_full_connection=false,ignore_report=true){const _kwargs=options.tuning_kwargs;const usable_ram_noswap=options.usable_ram;const usable_ram_noswap_hr=bytesize_to_hr(usable_ram_noswap);const total_ram=options.total_ram;const total_ram_hr=bytesize_to_hr(total_ram);const usable_ram_noswap_ratio=usable_ram_noswap/total_ram;const managed_cache=this.get_managed_cache(PGTUNER_SCOPE.DATABASE_CONFIG);const max_user_conns=(managed_cache['max_connections']-managed_cache['superuser_reserved_connections']-managed_cache['reserved_connections']);const os_conn_overhead=(max_user_conns*_kwargs.single_memory_connection_overhead*_kwargs.memory_connection_to_dedicated_os_ratio);let num_user_conns=max_user_conns;if(!use_full_connection){num_user_conns=Math.ceil(max_user_conns*_kwargs.effective_connection_ratio);}
const shared_buffers=managed_cache['shared_buffers'];const wal_buffers=managed_cache['wal_buffers'];const temp_buffers=managed_cache['temp_buffers'];const work_mem=managed_cache['work_mem'];const hash_mem_multiplier=managed_cache['hash_mem_multiplier'];const real_world_mem_scale=generalized_mean([1,hash_mem_multiplier],_kwargs.hash_mem_usage_level);const real_world_work_mem=work_mem*real_world_mem_scale;const total_working_memory=(temp_buffers+real_world_work_mem);const total_working_memory_hr=bytesize_to_hr(total_working_memory);let max_total_memory_used=shared_buffers+wal_buffers+os_conn_overhead;max_total_memory_used+=total_working_memory*num_user_conns;const max_total_memory_used_ratio=max_total_memory_used/usable_ram_noswap;const max_total_memory_used_hr=bytesize_to_hr(max_total_memory_used);if(ignore_report&&!_kwargs.mem_pool_parallel_estimate){return['',max_total_memory_used];}
const _parallel_report=this.calc_worker_in_parallel(options,num_user_conns);const num_parallel_workers=_parallel_report['num_parallel_workers'];const num_sessions=_parallel_report['num_sessions'];const num_sessions_in_parallel=_parallel_report['num_sessions_in_parallel'];const num_sessions_not_in_parallel=_parallel_report['num_sessions_not_in_parallel'];const parallel_work_mem_total=real_world_work_mem*(num_parallel_workers+num_sessions_in_parallel);const parallel_work_mem_in_session=real_world_work_mem*(1+managed_cache['max_parallel_workers_per_gather']);const single_work_mem_total=real_world_work_mem*num_sessions_not_in_parallel;let max_total_memory_used_with_parallel=shared_buffers+wal_buffers+os_conn_overhead;max_total_memory_used_with_parallel+=(parallel_work_mem_total+single_work_mem_total);max_total_memory_used_with_parallel+=temp_buffers*num_user_conns;const max_total_memory_used_with_parallel_ratio=max_total_memory_used_with_parallel/usable_ram_noswap;const max_total_memory_used_with_parallel_hr=bytesize_to_hr(max_total_memory_used_with_parallel);if(ignore_report&&_kwargs.mem_pool_parallel_estimate){return['',max_total_memory_used_with_parallel];}
const effective_cache_size=managed_cache['effective_cache_size'];const wal_throughput=options.wal_spec.perf()[0];const wal10=wal_time(wal_buffers,1.0,_kwargs.wal_segment_size,managed_cache['wal_writer_delay'],wal_throughput,options,managed_cache['wal_init_zero']);const wal15=wal_time(wal_buffers,1.5,_kwargs.wal_segment_size,managed_cache['wal_writer_delay'],wal_throughput,options,managed_cache['wal_init_zero']);const wal20=wal_time(wal_buffers,2.0,_kwargs.wal_segment_size,managed_cache['wal_writer_delay'],wal_throughput,options,managed_cache['wal_init_zero']);let real_autovacuum_work_mem=managed_cache['autovacuum_work_mem'];if(real_autovacuum_work_mem===-1){real_autovacuum_work_mem=managed_cache['maintenance_work_mem'];}
if(options.pgsql_version<17){real_autovacuum_work_mem=Math.min(1*Gi,real_autovacuum_work_mem);}
const[data_tput,data_iops]=options.data_index_spec.perf()
const checkpoint_timeout=managed_cache['checkpoint_timeout'];const checkpoint_completion_target=managed_cache['checkpoint_completion_target'];const _ckpt_iops=PG_DISK_PERF.throughput_to_iops(0.70*generalized_mean([PG_DISK_PERF.iops_to_throughput(data_iops),data_tput],-2.5));const ckpt05=checkpoint_time(checkpoint_timeout,checkpoint_completion_target,shared_buffers,0.05,effective_cache_size,managed_cache['max_wal_size'],_ckpt_iops);const ckpt30=checkpoint_time(checkpoint_timeout,checkpoint_completion_target,shared_buffers,0.30,effective_cache_size,managed_cache['max_wal_size'],_ckpt_iops);const ckpt95=checkpoint_time(checkpoint_timeout,checkpoint_completion_target,shared_buffers,0.95,effective_cache_size,managed_cache['max_wal_size'],_ckpt_iops);const bgwriter_page_per_second=Math.ceil(managed_cache['bgwriter_lru_maxpages']*(K10/managed_cache['bgwriter_delay']));const bgwriter_throughput=PG_DISK_PERF.iops_to_throughput(bgwriter_page_per_second);const vacuum_report=vacuum_time(managed_cache['vacuum_cost_page_hit'],managed_cache['vacuum_cost_page_miss'],managed_cache['vacuum_cost_page_dirty'],managed_cache['autovacuum_vacuum_cost_delay'],managed_cache['vacuum_cost_limit'],data_iops);const normal_vacuum=vacuum_scale(managed_cache['autovacuum_vacuum_threshold'],managed_cache['autovacuum_vacuum_scale_factor']);const normal_analyze=vacuum_scale(managed_cache['autovacuum_analyze_threshold'],managed_cache['autovacuum_analyze_scale_factor']);const _sampling_rows=300*managed_cache['default_statistics_target'];const num_hourly_write_transaction=options.num_write_transaction_per_hour_on_workload;const min_hr_txid=managed_cache['vacuum_freeze_min_age']/num_hourly_write_transaction;const norm_hr_txid=managed_cache['vacuum_freeze_table_age']/num_hourly_write_transaction;const max_hr_txid=managed_cache['autovacuum_freeze_max_age']/num_hourly_write_transaction;const min_hr_row_lock=managed_cache['vacuum_multixact_freeze_min_age']/num_hourly_write_transaction;const norm_hr_row_lock=managed_cache['vacuum_multixact_freeze_table_age']/num_hourly_write_transaction;const max_hr_row_lock=managed_cache['autovacuum_multixact_freeze_max_age']/num_hourly_write_transaction;const _report=`
# ===============================================================        
# Memory Estimation Test by ${APP_NAME_UPPER}
From server-side, the PostgreSQL memory usable arena is at most ${usable_ram_noswap_hr} or ${(usable_ram_noswap_ratio * 100).toFixed(2)} (%) of the total RAM (${total_ram_hr}).
    All other variables must be bounded and computed within the available memory.
    CPU: ${options.vcpu} logical cores
RAM: ${total_ram_hr} or ratio: ${((total_ram / options.vcpu / Gi).toFixed(1))}.

Arguments: use_full_connection=${use_full_connection}
Report Summary (memory, over usable RAM):
----------------------------------------
* PostgreSQL memory (estimate): ${max_total_memory_used_hr} or ${(max_total_memory_used_ratio * 100).toFixed(2)} (%) over usable RAM.
    - The Shared Buffers is ${bytesize_to_hr(shared_buffers)} or ${(shared_buffers / usable_ram_noswap * 100).toFixed(2)} (%)
    - The Wal Buffers is ${bytesize_to_hr(wal_buffers)} or ${(wal_buffers / usable_ram_noswap * 100).toFixed(2)} (%)
    - The connection overhead is ${bytesize_to_hr(os_conn_overhead)} with ${num_user_conns} total user connections
        + Active user connections: ${max_user_conns}
        + Peak assumption is at ${bytesize_to_hr(os_conn_overhead / _kwargs.memory_connection_to_dedicated_os_ratio)}
        + Reserved & Superuser Reserved Connections: ${managed_cache['max_connections'] - max_user_conns}
        + Need Connection Pool such as PgBouncer: ${num_user_conns >= 100}
    - The total maximum working memory (assuming with one full use of work_mem and temp_buffers):
        + SINGLE: ${total_working_memory_hr} per user connections or ${(total_working_memory / usable_ram_noswap * 100).toFixed(2)} (%)
            -> Real-World Mem Scale: ${(_kwargs.temp_buffers_ratio + (1 - _kwargs.temp_buffers_ratio) * real_world_mem_scale).toFixed(2)}
            -> Temp Buffers: ${bytesize_to_hr(temp_buffers)} :: Work Mem: ${bytesize_to_hr(work_mem)}
            -> Hash Mem Multiplier: ${hash_mem_multiplier} ::  Real-World Work Mem: ${bytesize_to_hr(real_world_work_mem)}
            -> Total: ${(total_working_memory * num_user_conns / usable_ram_noswap * 100).toFixed(2)} (%)
        + PARALLEL:
            -> Workers :: Gather Workers=${managed_cache['max_parallel_workers_per_gather']} :: Worker in Pool=${managed_cache['max_parallel_workers']} << Workers Process=${managed_cache['max_worker_processes']}
            -> Parallelized Session: ${num_sessions_in_parallel} :: Non-parallelized Session: ${num_sessions_not_in_parallel}
            -> Work memory assuming single query (1x work_mem)
                * Total parallelized sessions = ${num_sessions} with ${num_sessions_in_parallel - num_sessions} leftover session
                * Maximum work memory in parallelized session(s) without temp_buffers :
                    - 1 parallelized session: ${bytesize_to_hr(parallel_work_mem_in_session)} or ${(parallel_work_mem_in_session / usable_ram_noswap * 100).toFixed(2)} (%)
                    - Total (in parallel): ${bytesize_to_hr(parallel_work_mem_total)} or ${(parallel_work_mem_total / usable_ram_noswap * 100).toFixed(2)} (%)
                    - Total (in single): ${bytesize_to_hr(single_work_mem_total)} or ${(single_work_mem_total / usable_ram_noswap * 100).toFixed(2)} (%)
                * Maximum work memory in parallelized session(s) with temp_buffers:
                    - 1 parallelized session: ${bytesize_to_hr(parallel_work_mem_in_session + temp_buffers)} or ${((parallel_work_mem_in_session + temp_buffers) / usable_ram_noswap * 100).toFixed(2)} (%)
                    - Total (in parallel): ${bytesize_to_hr(parallel_work_mem_total + temp_buffers * num_user_conns)} or ${((parallel_work_mem_total + temp_buffers * num_user_conns) / usable_ram_noswap * 100).toFixed(2)} (%)
                    - Total (in single): ${bytesize_to_hr(single_work_mem_total + temp_buffers * num_user_conns)} or ${((single_work_mem_total + temp_buffers * num_user_conns) / usable_ram_noswap * 100).toFixed(2)} (%)
    - Effective Cache Size: ${bytesize_to_hr(effective_cache_size)} or ${(effective_cache_size / usable_ram_noswap * 100).toFixed(2)} (%)

* Zero parallelized session >> Memory in use: ${max_total_memory_used_hr}
    - Memory Ratio: ${(max_total_memory_used_ratio * 100).toFixed(2)} (%)
    - Normal Memory Usage: ${max_total_memory_used_ratio <= Math.min(1.0, _kwargs.max_normal_memory_usage)} (${(_kwargs.max_normal_memory_usage * 100).toFixed(1)} % memory threshold)
    - P3: Generally Safe in Workload: ${max_total_memory_used_ratio <= 0.70} (70 % memory threshold)
    - P2: Sufficiently Safe for Production: ${max_total_memory_used_ratio <= 0.80} (80 % memory threshold)
    - P1: Risky for Production: ${max_total_memory_used_ratio <= 0.90} (90 % memory threshold)
* With parallelized session >> Memory in use: ${max_total_memory_used_with_parallel_hr}
    - Memory Ratio: ${(max_total_memory_used_with_parallel_ratio * 100).toFixed(2)} (%)
    - Normal Memory Usage: ${max_total_memory_used_with_parallel_ratio <= Math.min(1.0, _kwargs.max_normal_memory_usage)} (${(_kwargs.max_normal_memory_usage * 100).toFixed(1)} % memory threshold)
    - P3: Generally Safe in Workload: ${max_total_memory_used_with_parallel_ratio <= 0.70} (70 % memory threshold)
    - P2: Sufficiently Safe for Production: ${max_total_memory_used_with_parallel_ratio <= 0.80} (80 % memory threshold)
    - P1: Risky for Production: ${max_total_memory_used_with_parallel_ratio <= 0.90} (90 % memory threshold)

Report Summary (others):
-----------------------  
* Maintenance and (Auto-)Vacuum:
    - Autovacuum (by definition): ${managed_cache['autovacuum_work_mem']}
        + Working memory per worker: ${bytesize_to_hr(real_autovacuum_work_mem)}
        + Max Workers: ${managed_cache['autovacuum_max_workers']} --> Total Memory: ${bytesize_to_hr(real_autovacuum_work_mem * managed_cache['autovacuum_max_workers'])} or ${(real_autovacuum_work_mem * managed_cache['autovacuum_max_workers'] / usable_ram_noswap * 100).toFixed(2)} (%)
    - Maintenance:
        + Max Workers: ${managed_cache['max_parallel_maintenance_workers']}
        + Total Memory: ${bytesize_to_hr(managed_cache['maintenance_work_mem'] * managed_cache['max_parallel_maintenance_workers'])} or ${(managed_cache['maintenance_work_mem'] * managed_cache['max_parallel_maintenance_workers'] / usable_ram_noswap * 100).toFixed(2)} (%)
        + Parallel table scan size: ${bytesize_to_hr(managed_cache['min_parallel_table_scan_size'])}
        + Parallel index scan size: ${bytesize_to_hr(managed_cache['min_parallel_index_scan_size'])}
    - Autovacuum Trigger (table-level):
        + Vacuum  :: Scale Factor=${(managed_cache['autovacuum_vacuum_scale_factor'] * 100).toFixed(2)} (%) :: Threshold=${managed_cache['autovacuum_vacuum_threshold']}
        + Analyze :: Scale Factor=${(managed_cache['autovacuum_analyze_scale_factor'] * 100).toFixed(2)} (%) :: Threshold=${managed_cache['autovacuum_analyze_threshold']}
        + Insert  :: Scale Factor=${(managed_cache['autovacuum_vacuum_insert_scale_factor'] * 100).toFixed(2)} (%) :: Threshold=${managed_cache['autovacuum_vacuum_insert_threshold']}
        Report when number of dead tuples is reached:
        + 10K rows :: Vacuum=${normal_vacuum['10k']} :: Insert/Analyze=${normal_analyze['10k']}
        + 300K rows :: Vacuum=${normal_vacuum['300k']} :: Insert/Analyze=${normal_analyze['300k']}
        + 10M rows :: Vacuum=${normal_vacuum['10m']} :: Insert/Analyze=${normal_analyze['10m']}
        + 100M rows :: Vacuum=${normal_vacuum['100m']} :: Insert/Analyze=${normal_analyze['100m']}
        + 1B rows :: Vacuum=${normal_vacuum['1b']} :: Insert/Analyze=${normal_analyze['1b']}
    - Cost-based Vacuum:  
        + Page Cost Relative Factor :: Hit=${managed_cache['vacuum_cost_page_hit']} :: Miss=${managed_cache['vacuum_cost_page_miss']} :: Dirty/Disk=${managed_cache['vacuum_cost_page_dirty']}
        + Autovacuum cost: ${managed_cache['autovacuum_vacuum_cost_limit']} --> Vacuum cost: ${managed_cache['vacuum_cost_limit']}
        + Autovacuum delay: ${managed_cache['autovacuum_vacuum_cost_delay']} (ms) --> Vacuum delay: ${managed_cache['vacuum_cost_delay']} (ms)
        + IOPS Spent: ${(data_iops * _kwargs.autovacuum_utilization_ratio).toFixed(1)} pages or ${PG_DISK_PERF.iops_to_throughput((data_iops * _kwargs.autovacuum_utilization_ratio).toFixed(1))} MiB/s
        + Vacuum Report on Worst Case Scenario:
            We safeguard against WRITE since most READ in production usually came from RAM/cache before auto-vacuuming, but not safeguard against pure, zero disk read.
            -> Hit (page in shared_buffers): Maximum ${vacuum_report['max_num_hit_page']} pages or RAM throughput ${(vacuum_report['max_hit_data']).toFixed(2)} MiB/s
                RAM Safety: ${vacuum_report['max_hit_data'] < 10 * K10} (< 10 GiB/s for low DDR3)
            -> Miss (page in disk cache): Maximum ${vacuum_report['max_num_miss_page']} pages or Disk throughput ${(vacuum_report['max_miss_data']).toFixed(2)} MiB/s
                # See encoding here: https://en.wikipedia.org/wiki/64b/66b_encoding; NVME SSD with PCIe 3.0+ or USB 3.1
                NVME10 Safety: ${vacuum_report['max_miss_data'] < 10 / 8 * 64 / 66 * K10} (< 10 GiB/s, 64b/66b encoding)
                SATA3 Safety: ${vacuum_report['max_miss_data'] < 6 / 8 * 6 / 8 * K10} (< 6 GiB/s, 6b/8b encoding)
                Disk Safety: ${vacuum_report['max_num_miss_page'] < data_iops} (< Data Disk IOPS)
            -> Dirty (page in data disk volume): Maximum ${vacuum_report['max_num_dirty_page']} pages or Disk throughput ${(vacuum_report['max_dirty_data']).toFixed(2)} MiB/s
                Disk Safety: ${vacuum_report['max_num_dirty_page'] < data_iops} (< Data Disk IOPS)
        + Other Scenarios with H:M:D ratio as 5:5:1 (frequent), or 1:1:1 (rarely)
            5:5:1 or ${vacuum_report['5:5:1_page'] * 6} disk pages -> IOPS capacity of ${(vacuum_report['5:5:1_data']).toFixed(2)} MiB/s (write=${(vacuum_report['5:5:1_data'] * 1 / 6).toFixed(2)} MiB/s)
            -> Safe: ${vacuum_report['5:5:1_page'] * 6 < data_iops} (< Data Disk IOPS)
            1:1:1 or ${vacuum_report['1:1:1_page'] * 3} disk pages -> IOPS capacity of ${(vacuum_report['1:1:1_data']).toFixed(2)} MiB/s (write=${(vacuum_report['1:1:1_data'] * 1 / 2).toFixed(2)} MiB/s)
            -> Safe: ${vacuum_report['1:1:1_page'] * 3 < data_iops} (< Data Disk IOPS)
    - Transaction (Tran) ID Wraparound and Anti-Wraparound Vacuum:
        + Workload Write Transaction per Hour: ${num_hourly_write_transaction}
        + TXID Vacuum :: Minimum=${min_hr_txid.toFixed(2)} hrs :: Manual=${norm_hr_txid.toFixed(2)} hrs :: Auto-forced=${max_hr_txid.toFixed(2)} hrs
        + XMIN,XMAX Vacuum :: Minimum=${min_hr_row_lock.toFixed(2)} hrs :: Manual=${norm_hr_row_lock.toFixed(2)} hrs :: Auto-forced=${max_hr_row_lock.toFixed(2)} hrs

* Background Writers:
    - Delay: ${managed_cache['bgwriter_delay']} (ms) for maximum ${managed_cache['bgwriter_lru_maxpages']} dirty pages
        + ${bgwriter_page_per_second} pages per second or ${bgwriter_throughput.toFixed(1)} MiB/s in random WRITE IOPs

* Checkpoint:        
    - Effective Timeout: ${(checkpoint_timeout * checkpoint_completion_target).toFixed(1)} seconds (${checkpoint_timeout}::${checkpoint_completion_target})
    - Checkpoint timing analysis at 70% random IOPS:
        + 5% of shared_buffers:
            -> Data Amount: ${bytesize_to_hr(ckpt05['data_amount'])} :: ${ckpt05['page_amount']} pages
            -> Expected Time: ${ckpt05['data_write_time']} seconds with ${ckpt05['data_disk_utilization'] * 100} (%) utilization
            -> Safe Test :: Time-based Check <- ${ckpt05['data_write_time'] <= checkpoint_timeout * checkpoint_completion_target}
        + 30% of shared_buffers:
            -> Data Amount: ${bytesize_to_hr(ckpt30['data_amount'])} :: ${ckpt30['page_amount']} pages
            -> Expected Time: ${ckpt30['data_write_time']} seconds with ${ckpt30['data_disk_utilization'] * 100} (%) utilization
            -> Safe Test :: Time-based Check <- ${ckpt30['data_write_time'] <= checkpoint_timeout * checkpoint_completion_target}
        + 95% of shared_buffers:
            -> Data Amount: ${bytesize_to_hr(ckpt95['data_amount'])} :: ${ckpt95['page_amount']} pages
            -> Expected Time: ${ckpt95['data_write_time']} seconds with ${ckpt95['data_disk_utilization'] * 100} (%) utilization
            -> Safe Test :: Time-based Check <- ${ckpt95['data_write_time'] <= checkpoint_timeout * checkpoint_completion_target}
            
* Query Planning and Optimization:
    - Page Cost :: Sequential=${managed_cache['seq_page_cost'].toFixed(2)} :: Random=${managed_cache['random_page_cost'].toFixed(2)}
    - CPU Cost :: Tuple=${managed_cache['cpu_tuple_cost'].toFixed(4)} :: Index=${managed_cache['cpu_index_tuple_cost'].toFixed(4)} :: Operator=${managed_cache['cpu_operator_cost'].toFixed(4)}
    - Bitmap Heap Planning :: Workload=${managed_cache['effective_io_concurrency']} :: Maintenance=${managed_cache['maintenance_io_concurrency']}
    - Parallelism :: Setup=${managed_cache['parallel_setup_cost']} :: Tuple=${managed_cache['parallel_tuple_cost'].toFixed(2)}
    - Batched Commit Delay: ${managed_cache['commit_delay']} (ms)
    
* Write-Ahead Logging and Data Integrity:
    - WAL Level: ${managed_cache['wal_level']} with ${managed_cache['wal_compression']} compression algorithm
    - WAL Segment Size (1 file): ${bytesize_to_hr(_kwargs.wal_segment_size)}
    - Integrity:
        + Synchronous Commit: ${managed_cache['synchronous_commit']}
        + Full Page Writes: ${managed_cache['full_page_writes']}
        + Fsync: ${managed_cache['fsync']}
    - Buffers Write Cycle within Data Loss Time: ${options.max_time_transaction_loss_allow_in_millisecond} ms (depend on WAL volume throughput)
        + 1.0x when opt_wal_buffers=${PG_PROFILE_OPTMODE.SPIDEY}:
            -> Elapsed Time :: Rotate: ${wal10['rotate_time'].toFixed(2)} ms :: Write: ${wal10['write_time'].toFixed(2)} ms :: Delay: ${wal10['delay_time'].toFixed(2)} ms
            -> Total Time :: ${wal10['total_time'].toFixed(2)} ms during ${wal10['num_wal_files']} WAL files
            -> OK for Transaction Loss: ${wal10['total_time'] <= options.max_time_transaction_loss_allow_in_millisecond}
        + 1.5x when opt_wal_buffers=${PG_PROFILE_OPTMODE.OPTIMUS_PRIME}:
            -> Elapsed Time :: Rotate: ${wal15['rotate_time'].toFixed(2)} ms :: Write: ${wal15['write_time'].toFixed(2)} ms :: Delay: ${wal15['delay_time'].toFixed(2)} ms
            -> Total Time :: ${wal15['total_time'].toFixed(2)} ms during ${wal15['num_wal_files']} WAL files
            -> OK for Transaction Loss: ${wal15['total_time'] <= options.max_time_transaction_loss_allow_in_millisecond}
        + 2.0x when opt_wal_buffers=${PG_PROFILE_OPTMODE.PRIMORDIAL}:
            -> Elapsed Time :: Rotate: ${wal20['rotate_time'].toFixed(2)} ms :: Write: ${wal20['write_time'].toFixed(2)} ms :: Delay: ${wal20['delay_time'].toFixed(2)} ms
            -> Total Time :: ${wal20['total_time'].toFixed(2)} ms during ${wal20['num_wal_files']} WAL files
            -> OK for Transaction Loss: ${wal20['total_time'] <= options.max_time_transaction_loss_allow_in_millisecond}
    - WAL Sizing:  
        + Max WAL Size for Automatic Checkpoint: ${bytesize_to_hr(managed_cache['max_wal_size'])} or ${managed_cache['max_wal_size'] / options.wal_spec.perf()[0]} seconds
        + Min WAL Size for WAL recycle instead of removal: ${bytesize_to_hr(managed_cache['min_wal_size'])}
            -> Disk usage must below ${((1 - managed_cache['min_wal_size'] / options.wal_spec.disk_usable_size) * 100).toFixed(2)} (%)
        + WAL Keep Size for PITR/Replication: ${bytesize_to_hr(managed_cache['wal_keep_size'])} or minimum ${(managed_cache['wal_keep_size'] / options.wal_spec.disk_usable_size * 100).toFixed(2)} (%)
    
* Timeout:
    - Idle-in-Transaction Session Timeout: ${managed_cache['idle_in_transaction_session_timeout']} seconds
    - Statement Timeout: ${managed_cache['statement_timeout']} seconds
    - Lock Timeout: ${managed_cache['lock_timeout']} seconds
        
WARNING (if any) and DISCLAIMER:
------------------------------------------
* These calculations could be incorrect due to capping, precision adjustment, rounding; and it is 
just the estimation. Please take proper consultant and testing to verify the actual memory usage, 
and bottleneck between processes.
* The working memory whilst the most critical part are in the assumption of **basic** full usage 
(one single HASH-based query and one CTE) and all connections are in the same state. It is best 
to test it under your **real** production business workload rather than this estimation report.
* For the autovacuum threshold, it is best to adjust it based on the actual table size, its 
active portion compared to the total size and its time, and the actual update/delete/insert 
rate to avoid bloat rather than using our above setting; but for general use, the current 
default is OK unless you are working on table with billion of rows or more.    
* Update the timeout based on your business requirement, database workload, and the 
application's behavior.
* Not every parameter can be covered or tuned, and not every parameter can be added as-is.
As mentioned, consult with your developer, DBA, and system administrator to ensure the
best performance and reliability of the database system.
# ===============================================================      
        `;return[_report,(!_kwargs.mem_pool_parallel_estimate?max_total_memory_used:max_total_memory_used_with_parallel)];}
calc_worker_in_parallel(options,num_active_user_conns){const managed_cache=this.get_managed_cache(PGTUNER_SCOPE.DATABASE_CONFIG);const _kwargs=options.tuning_kwargs;const num_parallel_workers=Math.min(managed_cache['max_parallel_workers'],managed_cache['max_worker_processes']);const remain_workers=num_parallel_workers%managed_cache['max_parallel_workers_per_gather'];const num_sessions=Math.floor((num_parallel_workers-remain_workers)/managed_cache['max_parallel_workers_per_gather']);const num_sessions_in_parallel=num_sessions+(remain_workers>0?1:0);const num_sessions_not_in_parallel=Math.max(0,num_active_user_conns-num_sessions_in_parallel);return{'num_parallel_workers':num_parallel_workers,'num_sessions':num_sessions,'num_sessions_in_parallel':num_sessions_in_parallel,'num_sessions_not_in_parallel':num_sessions_not_in_parallel,'work_mem_parallel_scale':(num_parallel_workers+num_sessions_in_parallel+num_sessions_not_in_parallel)/num_active_user_conns}}}
function _VarTune(request,response,group_cache,global_cache,tune_op,default_value){if(tune_op!==null){try{return[tune_op(group_cache,global_cache,request.options,response),tune_op];}catch(e){console.error(`Error in tuning operation: ${e} --> Returning the default value.`);}}
return[default_value,default_value];}
function _MakeItm(key,before,after,trigger,tuneEntry,hardwareScope){return new PG_TUNE_ITEM({key:key,before:before,after:after,trigger:trigger,hardware_scope:hardwareScope,comment:tuneEntry.hasOwnProperty('comment')?tuneEntry['comment']:null,style:tuneEntry.hasOwnProperty('style')?tuneEntry['style']:null,partial_func:tuneEntry.hasOwnProperty('partial_func')?tuneEntry['partial_func']:null});}
function _GetFnDefault(key,tune_entry,hw_scope){let msg='';if(!(tune_entry.hasOwnProperty('instructions'))){msg=`DEBUG: Profile-based tuning is not found for this item ${key} -> Use the general tuning instead.`;console.debug(msg);const fn=tune_entry.hasOwnProperty('tune_op')?tune_entry['tune_op']:null;const default_value=tune_entry['default'];return[fn,default_value,msg];}
let profile_fn=null;if(tune_entry['instructions'].hasOwnProperty(`${hw_scope.value}`)){profile_fn=tune_entry['instructions'][`${hw_scope.value}`];}else if(tune_entry.hasOwnProperty('tune_op')){profile_fn=tune_entry['tune_op'];}
let profile_default=null;if(tune_entry['instructions'].hasOwnProperty(`${hw_scope.value}_default`)){profile_default=tune_entry['instructions'][`${hw_scope.value}_default`];}
if(profile_default===null){profile_default=tune_entry['default'];if(profile_fn===null||typeof profile_fn!=='function'){msg=`WARNING: Profile-based tuning function collection is not found for this item ${key} and the associated hardware scope '${hw_scope.value}' is NOT found, pushing to use the generic default.`;console.warn(msg);}}
return[profile_fn,profile_default,msg];}
function Optimize(request,response,target,target_items){const global_cache=response.outcome_cache[target];for(const[unused_1,[scope,category,unused_2]]of Object.entries(target_items)){const group_cache={};const group_itm=[];const managed_items=response.get_managed_items(target,scope);console.info(`\n====== Start the tuning process with scope: ${scope} ======`);for(const[mkey,tune_entry]of Object.entries(category)){const keys=mkey.split(MULTI_ITEMS_SPLIT);const key=keys[0].trim();const hw_scope_term=tune_entry.hasOwnProperty('hardware_scope')?tune_entry['hardware_scope']:'overall';const hw_scope_value=request.options.translate_hardware_scope(hw_scope_term);const[fn,default_value,msg]=_GetFnDefault(key,tune_entry,hw_scope_value);const[result,triggering]=_VarTune(request,response,group_cache,global_cache,fn,default_value);const itm=_MakeItm(key,null,result!==null?result:tune_entry['default'],triggering,tune_entry,[hw_scope_term,hw_scope_value]);console.debug(key,tune_entry,'-->',itm);if(itm===null||itm.after===null){console.warn(`WARNING: Error in tuning the variable as default value is not found or set to null for '${key}' -> Skipping and not adding to the final result.`);continue;}
if(tune_entry.hasOwnProperty('post-condition')&&typeof tune_entry['post-condition']==='function'){if(tune_entry['post-condition'](itm.after)===false){console.error(`ERROR: Post-condition self-check of '${key}' failed on new value ${itm.after}. Skipping and not adding to the final result.`);continue;}}
if(tune_entry.hasOwnProperty('post-condition-group')&&typeof tune_entry['post-condition-group']==='function'){if(tune_entry['post-condition-group'](itm.after,group_cache,request.options)===false){console.error(`ERROR: Post-condition group-check of '${key}' failed on new value ${itm.after}. Skipping and not adding to the final result.`);continue;}}
group_cache[key]=itm.after;const post_condition_all_fn=tune_entry.hasOwnProperty('post-condition-all')?tune_entry['post-condition-all']:null;group_itm.push([itm,post_condition_all_fn]);console.debug(`Variable '${key}' has been tuned from ${itm.before} to ${itm.out_display()}.`);for(const k of keys.slice(1)){const sub_key=k.trim();const cloned_itm=_MakeItm(sub_key,null,result||tune_entry.default,triggering,tune_entry,[hw_scope_term,hw_scope_value]);group_cache[sub_key]=cloned_itm.after;group_itm.push([cloned_itm,post_condition_all_fn]);console.debug(`Variable '${sub_key}' has been tuned from ${cloned_itm.before} to ${cloned_itm.out_display()} by copying the tuning result from '${key}'.`);}}
for(const[itm,post_func]of group_itm){if(post_func!==null&&!post_func(itm.after,group_cache,request.options)){console.error(`ERROR: Post-condition total-check of '${itm.key}' failed on new value ${itm.after}. The tuning item is not added to the final result.`);continue;}
global_cache[itm.key]=itm.after;managed_items[itm.key]=itm;}}}
const _MIN_USER_CONN_FOR_ANALYTICS=4
const _MAX_USER_CONN_FOR_ANALYTICS=25
const _DEFAULT_WAL_SENDERS=[3,5,7]
const _TARGET_SCOPE=PGTUNER_SCOPE.DATABASE_CONFIG
function _TriggerAutoTune(keys,request,response){const managed_cache=response.get_managed_cache(_TARGET_SCOPE)
const change_list=[]
for(const[scope,items]of Object.entries(keys)){const managed_items=response.get_managed_items(_TARGET_SCOPE,scope)
for(const key of items){if(!(managed_items.hasOwnProperty(key))){console.warn(`WARNING: The ${key} is not found in the managed tuning item list, probably the scope is invalid.`)
continue}
const t_itm=managed_items[key]
if(t_itm!==null&&typeof t_itm.trigger==='function'){const old_result=managed_cache[key]
t_itm.after=t_itm.trigger(managed_cache,managed_cache,request.options,response)
managed_cache[key]=t_itm.after
if(old_result!==t_itm.after){change_list.push([key,t_itm.out_display()])}}}}
if(change_list.length>0){console.info(`The following items are updated: ${change_list}`)}else{console.info('No change is detected in the trigger tuning.')}
return null;}
function _ApplyItmTune(key,after,scope,response,suffix_text=''){const items=response.get_managed_items(_TARGET_SCOPE,scope)
const cache=response.get_managed_cache(_TARGET_SCOPE)
if(!(key in items)||!(key in cache)){const msg=`WARNING: The ${key} is not found in the managed tuning item list, probably the scope is invalid.`
console.error(msg)
throw new Error(msg)}
const before=cache[key]
console.info(`The ${key} is updated from ${before} (or ${items[key].out_display()}) to ${after} (or ${items[key].out_display(override_value=after)}) ${suffix_text}.`)
items[key].after=after
cache[key]=after
return null}
function _conn_cache_query_timeout_tune(request,response){console.info(`===== CPU & Statistics Tuning =====`)
console.info(`Start tuning the connection, statistic caching, disk cache of the PostgreSQL database server based on the database workload. \nImpacted Attributes: max_connections, temp_buffers, work_mem, effective_cache_size, idle_in_transaction_session_timeout.`)
const _kwargs=request.options.tuning_kwargs
const managed_cache=response.get_managed_cache(_TARGET_SCOPE)
const workload_type=request.options.workload_type
if(_kwargs.user_max_connections>0){console.info('The user has overridden the max_connections -> Skip the maximum tuning')}else if(workload_type===PG_WORKLOAD.OLAP){console.info('The workload type is primarily managed by the application such as full-based analytics or logging/blob storage workload. ')
const max_connections='max_connections'
const reserved_connections=managed_cache['reserved_connections']+managed_cache['superuser_reserved_connections']
const new_result=cap_value(managed_cache[max_connections]-reserved_connections,Math.max(_MIN_USER_CONN_FOR_ANALYTICS,reserved_connections),Math.max(_MAX_USER_CONN_FOR_ANALYTICS,reserved_connections))
_ApplyItmTune(max_connections,new_result+reserved_connections,PG_SCOPE.CONNECTION,response)
const updates={[PG_SCOPE.MEMORY]:['temp_buffers','work_mem'],[PG_SCOPE.QUERY_TUNING]:['effective_cache_size']}
_TriggerAutoTune(updates,request,response);}else{console.info('The connection tuning is ignored due to applied workload type does not match expectation.')}
const user_connections=(managed_cache['max_connections']-managed_cache['reserved_connections']
-managed_cache['superuser_reserved_connections'])
if(user_connections>_MAX_USER_CONN_FOR_ANALYTICS){const tmp_user_conn=(user_connections-_MAX_USER_CONN_FOR_ANALYTICS)
const after_idle_in_transaction_session_timeout=managed_cache['idle_in_transaction_session_timeout']-30*SECOND*(tmp_user_conn/25)
_ApplyItmTune('idle_in_transaction_session_timeout',Math.max(31,after_idle_in_transaction_session_timeout),PG_SCOPE.OTHERS,response)}
console.info(`Start tuning the query timeout of the PostgreSQL database server based on the database workload. \nImpacted Attributes: statement_timeout, lock_timeout, cpu_tuple_cost, parallel_tuple_cost, default_statistics_target, commit_delay.`)
const workload_translations={[PG_WORKLOAD.TSR_IOT]:[0.0075,5*MINUTE],[PG_WORKLOAD.VECTOR]:[0.025,10*MINUTE],[PG_WORKLOAD.OLTP]:[0.015,10*MINUTE],[PG_WORKLOAD.HTAP]:[0.025,30*MINUTE],[PG_WORKLOAD.OLAP]:[0.03,60*MINUTE]}
const suffix_text=`by workload: ${workload_type}`
if(workload_type in workload_translations){const[new_cpu_tuple_cost,base_timeout]=workload_translations[workload_type]
_ApplyItmTune('cpu_tuple_cost',new_cpu_tuple_cost,PG_SCOPE.QUERY_TUNING,response,suffix_text)
const updates={[PG_SCOPE.QUERY_TUNING]:['parallel_tuple_cost']}
_TriggerAutoTune(updates,request,response)
_ApplyItmTune('lock_timeout',base_timeout,PG_SCOPE.OTHERS,response,suffix_text)
_ApplyItmTune('statement_timeout',base_timeout+7,PG_SCOPE.OTHERS,response,suffix_text)}
const default_statistics_target='default_statistics_target'
let managed_items=response.get_managed_items(_TARGET_SCOPE,PG_SCOPE.QUERY_TUNING)
let after_default_statistics_target
let default_statistics_target_hw_scope=managed_items[default_statistics_target].hardware_scope[1]
if(workload_type===PG_WORKLOAD.OLAP||workload_type===PG_WORKLOAD.HTAP){after_default_statistics_target=200+125*Math.max(default_statistics_target_hw_scope.num(),0)}else{after_default_statistics_target=200+100*Math.max(default_statistics_target_hw_scope.num()-1,0)}
_ApplyItmTune(default_statistics_target,after_default_statistics_target,PG_SCOPE.QUERY_TUNING,response,suffix_text)
let commit_delay_hw_scope=managed_items['commit_delay'].hardware_scope[1]
let after_commit_delay=Math.floor(K10/10*2.5*(commit_delay_hw_scope.num()+1))
after_commit_delay=cap_value(after_commit_delay,0,2*K10)
_ApplyItmTune('commit_delay',after_commit_delay,PG_SCOPE.QUERY_TUNING,response)
_ApplyItmTune('commit_siblings',5+3*managed_items['commit_siblings'].hardware_scope[1].num(),PG_SCOPE.QUERY_TUNING,response)
return null;}
function _generic_disk_bgwriter_vacuum_wraparound_vacuum_tune(request,response){console.info(`\n ===== Disk-based Tuning =====`)
console.info(`Start tuning the disk-based I/O, background writer, and vacuuming of the PostgreSQL database server based on the database workload. \nImpacted Attributes: effective_io_concurrency, bgwriter_lru_maxpages, bgwriter_delay, autovacuum_vacuum_cost_limit, autovacuum_vacuum_cost_delay, autovacuum_vacuum_scale_factor, autovacuum_vacuum_threshold.`)
const managed_cache=response.get_managed_cache(_TARGET_SCOPE)
const _kwargs=request.options.tuning_kwargs
const data_iops=request.options.data_index_spec.perf()[1]
let after_random_page_cost=1.01
if(PG_DISK_SIZING.matchDiskSeries(data_iops,RANDOM_IOPS,`hdd`,`weak`)){after_random_page_cost=2.60}else if(PG_DISK_SIZING.matchDiskSeries(data_iops,RANDOM_IOPS,`hdd`,`strong`)){after_random_page_cost=2.20}else if(PG_DISK_SIZING.matchDiskSeries(data_iops,RANDOM_IOPS,`san`,`weak`)){after_random_page_cost=1.75}else if(PG_DISK_SIZING.matchDiskSeries(data_iops,RANDOM_IOPS,`san`,`strong`)){after_random_page_cost=1.50}else if(PG_DISK_SIZING.matchOneDisk(data_iops,RANDOM_IOPS,PG_DISK_SIZING.SSDv1)){after_random_page_cost=1.25}else if(PG_DISK_SIZING.matchOneDisk(data_iops,RANDOM_IOPS,PG_DISK_SIZING.SSDv2)){after_random_page_cost=1.20}else if(PG_DISK_SIZING.matchOneDisk(data_iops,RANDOM_IOPS,PG_DISK_SIZING.SSDv3)){after_random_page_cost=1.15}else if(PG_DISK_SIZING.matchOneDisk(data_iops,RANDOM_IOPS,PG_DISK_SIZING.SSDv4)){after_random_page_cost=1.10}else if(PG_DISK_SIZING.matchOneDisk(data_iops,RANDOM_IOPS,PG_DISK_SIZING.SSDv5)){after_random_page_cost=1.05}
_ApplyItmTune('random_page_cost',after_random_page_cost,PG_SCOPE.QUERY_TUNING,response)
let after_effective_io_concurrency=managed_cache['effective_io_concurrency']
if(PG_DISK_SIZING.matchDiskSeries(data_iops,RANDOM_IOPS,'nvmepciev5')){after_effective_io_concurrency=512}else if(PG_DISK_SIZING.matchDiskSeries(data_iops,RANDOM_IOPS,'nvmepciev4')){after_effective_io_concurrency=384}else if(PG_DISK_SIZING.matchDiskSeries(data_iops,RANDOM_IOPS,'nvmepciev3')){after_effective_io_concurrency=256}else if(PG_DISK_SIZING.matchDiskSeries(data_iops,RANDOM_IOPS,'ssd','strong')||PG_DISK_SIZING.matchDiskSeries(data_iops,RANDOM_IOPS,'nvmebox')){after_effective_io_concurrency=224}else if(PG_DISK_SIZING.matchDiskSeries(data_iops,RANDOM_IOPS,'ssd','weak')){after_effective_io_concurrency=192}else if(PG_DISK_SIZING.matchDiskSeries(data_iops,RANDOM_IOPS,'san','strong')){after_effective_io_concurrency=160}else if(PG_DISK_SIZING.matchDiskSeries(data_iops,RANDOM_IOPS,'san','weak')){after_effective_io_concurrency=128}else if(PG_DISK_SIZING.matchOneDisk(data_iops,RANDOM_IOPS,PG_DISK_SIZING.HDDv3)){after_effective_io_concurrency=64}else if(PG_DISK_SIZING.matchOneDisk(data_iops,RANDOM_IOPS,PG_DISK_SIZING.HDDv2)){after_effective_io_concurrency=32}
let after_maintenance_io_concurrency=Math.max(16,after_effective_io_concurrency/2)
after_effective_io_concurrency=cap_value(after_effective_io_concurrency,16,K10)
after_maintenance_io_concurrency=cap_value(after_maintenance_io_concurrency,16,K10)
_ApplyItmTune('effective_io_concurrency',after_effective_io_concurrency,PG_SCOPE.OTHERS,response)
_ApplyItmTune('maintenance_io_concurrency',after_maintenance_io_concurrency,PG_SCOPE.OTHERS,response)
if(request.options.operating_system!=='windows'){let after_checkpoint_flush_after=managed_cache['checkpoint_flush_after']
let after_wal_writer_flush_after=managed_cache['wal_writer_flush_after']
let after_bgwriter_flush_after=managed_cache['bgwriter_flush_after']
if(PG_DISK_SIZING.matchDiskSeries(data_iops,RANDOM_IOPS,'san','strong')){after_checkpoint_flush_after=512*Ki
after_bgwriter_flush_after=512*Ki}else if(PG_DISK_SIZING.matchDiskSeriesInRange(data_iops,RANDOM_IOPS,'ssd','nvme')){after_checkpoint_flush_after=1*Mi
after_bgwriter_flush_after=1*Mi}
_ApplyItmTune('bgwriter_flush_after',after_bgwriter_flush_after,PG_SCOPE.OTHERS,response)
_ApplyItmTune('checkpoint_flush_after',after_checkpoint_flush_after,PG_SCOPE.ARCHIVE_RECOVERY_BACKUP_RESTORE,response)
let wal_tput=request.options.wal_spec.perf()[0]
if(PG_DISK_SIZING.matchDiskSeries(wal_tput,THROUGHPUT,'san','strong')||PG_DISK_SIZING.matchDiskSeriesInRange(wal_tput,THROUGHPUT,'ssd','nvme')){after_wal_writer_flush_after=2*Mi
if(request.options.workload_profile>=PG_SIZING.LARGE){after_wal_writer_flush_after*=2}}
_ApplyItmTune('wal_writer_flush_after',after_wal_writer_flush_after,PG_SCOPE.ARCHIVE_RECOVERY_BACKUP_RESTORE,response)
let after_backend_flush_after=Math.min(managed_cache['checkpoint_flush_after'],managed_cache['bgwriter_flush_after'])
_ApplyItmTune('backend_flush_after',after_backend_flush_after,PG_SCOPE.OTHERS,response)}else{_ApplyItmTune('checkpoint_flush_after',0,PG_SCOPE.ARCHIVE_RECOVERY_BACKUP_RESTORE,response)
_ApplyItmTune('bgwriter_flush_after',0,PG_SCOPE.OTHERS,response)
_ApplyItmTune('wal_writer_flush_after',0,PG_SCOPE.ARCHIVE_RECOVERY_BACKUP_RESTORE,response)}
console.info(`Start tuning the autovacuum of the PostgreSQL database server based on the database workload.\nImpacted Attributes: bgwriter_lru_maxpages, bgwriter_delay.`)
let after_bgwriter_delay=Math.floor(Math.max(100,managed_cache['bgwriter_delay']-8*data_iops/K10))
_ApplyItmTune('bgwriter_delay',after_bgwriter_delay,PG_SCOPE.OTHERS,response)
if((request.options.workload_type===PG_WORKLOAD.VECTOR&&request.options.workload_profile>=PG_SIZING.MALL)||request.options.workload_type!==PG_WORKLOAD.VECTOR){let after_bgwriter_lru_maxpages=Math.floor(managed_cache['bgwriter_lru_maxpages'])
if(PG_DISK_SIZING.matchDiskSeries(data_iops,RANDOM_IOPS,'ssd','weak')){after_bgwriter_lru_maxpages+=100}else if(PG_DISK_SIZING.matchDiskSeries(data_iops,RANDOM_IOPS,'ssd','strong')){after_bgwriter_lru_maxpages+=100+150}else if(PG_DISK_SIZING.matchDiskSeries(data_iops,RANDOM_IOPS,'nvme')){after_bgwriter_lru_maxpages+=100+150+200}
_ApplyItmTune('bgwriter_lru_maxpages',after_bgwriter_lru_maxpages,PG_SCOPE.OTHERS,response)}
console.log(`Start tuning the autovacuum of the PostgreSQL database server based on the database workload.`)
console.log(`Impacted Attributes: autovacuum_vacuum_cost_delay, vacuum_cost_page_dirty, *_vacuum_cost_limit, *_freeze_min_age, *_failsafe_age, *_table_age`)
let after_vacuum_cost_page_miss=3
let after_autovacuum_vacuum_cost_delay=12
let after_vacuum_cost_page_dirty=15
if(PG_DISK_SIZING.matchDiskSeries(data_iops,RANDOM_IOPS,'hdd','weak')){after_autovacuum_vacuum_cost_delay=15
after_vacuum_cost_page_dirty=15}else if(PG_DISK_SIZING.matchDiskSeries(data_iops,RANDOM_IOPS,'ssd')||PG_DISK_SIZING.matchDiskSeries(data_iops,RANDOM_IOPS,'nvme')){after_autovacuum_vacuum_cost_delay=5
after_vacuum_cost_page_dirty=10}
_ApplyItmTune('vacuum_cost_page_miss',after_vacuum_cost_page_miss,PG_SCOPE.MAINTENANCE,response)
_ApplyItmTune('autovacuum_vacuum_cost_delay',after_autovacuum_vacuum_cost_delay,PG_SCOPE.MAINTENANCE,response)
_ApplyItmTune('vacuum_cost_page_dirty',after_vacuum_cost_page_dirty,PG_SCOPE.MAINTENANCE,response)
const autovacuum_max_page_per_sec=Math.floor(data_iops*_kwargs.autovacuum_utilization_ratio)
let _delay;if(request.options.operating_system==='windows'){_delay=Math.max(1.0,after_autovacuum_vacuum_cost_delay+0.5)}else{_delay=Math.max(0.05,after_autovacuum_vacuum_cost_delay+0.02)}
_delay+=0.005
_delay*=1.025
const autovacuum_max_page_per_cycle=Math.floor(autovacuum_max_page_per_sec/K10*_delay)
const miss=12-_kwargs.vacuum_safety_level
const dirty=_kwargs.vacuum_safety_level
const vacuum_cost_model=(managed_cache['vacuum_cost_page_miss']*miss+
managed_cache['vacuum_cost_page_dirty']*dirty)/(miss+dirty)
const after_vacuum_cost_limit=realign_value(Math.floor(autovacuum_max_page_per_cycle*vacuum_cost_model),after_vacuum_cost_page_dirty+after_vacuum_cost_page_miss)[request.options.align_index]
_ApplyItmTune('vacuum_cost_limit',after_vacuum_cost_limit,PG_SCOPE.MAINTENANCE,response)
console.info(`Start tuning the autovacuum of the PostgreSQL database server based on the database workload.\nImpacted Attributes: *_freeze_min_age, *_failsafe_age, *_table_age`)
const _transaction_rate=request.options.num_write_transaction_per_hour_on_workload
const _transaction_coef=request.options.workload_profile.num()
const _future_data_scaler=2.5+(0.5*_transaction_coef)
const _data_tput=request.options.data_index_spec.perf()[0]
const _wraparound_effective_io=0.80
const _data_tran_tput=PG_DISK_PERF.iops_to_throughput(data_iops)
const _data_avg_tput=generalized_mean([_data_tran_tput,_data_tput],0.85)
const _data_size=0.75*request.options.database_size_in_gib*Ki
const _index_size=0.25*request.options.database_size_in_gib*Ki
const _fsm_vm_size=Math.floor(_data_size/256)
const _failsafe_data_size=(2*_fsm_vm_size+2*_data_size)
let _failsafe_hour=(2*_fsm_vm_size/(_data_tput*_wraparound_effective_io))/HOUR
_failsafe_hour+=(_failsafe_data_size/(_data_tput*_wraparound_effective_io))/HOUR
console.log(`In the worst-case scenario (where failsafe triggered and cost-based vacuum is disabled), the amount of data read and write is usually twice the data files, resulting in ${_failsafe_data_size} MiB with effective throughput of ${(_wraparound_effective_io * 100).toFixed(1)}% or ${(_data_tput * _wraparound_effective_io).toFixed(1)} MiB/s; Thereby having a theoretical worst-case of ${_failsafe_hour.toFixed(1)} hours for failsafe vacuuming, and a safety scale factor of ${_future_data_scaler.toFixed(1)} times the worst-case scenario.`)
let _norm_hour=(2*_fsm_vm_size/(_data_tput*_wraparound_effective_io))/HOUR
_norm_hour+=((_data_size+_index_size)/(_data_tput*_wraparound_effective_io))/HOUR
_norm_hour+=((0.35*(_data_size+_index_size))/(_data_avg_tput*_wraparound_effective_io))/HOUR
const _data_vacuum_time=Math.max(_norm_hour,_failsafe_hour)
const _worst_data_vacuum_time=_data_vacuum_time*_future_data_scaler
console.info(`WARNING: The anti-wraparound vacuuming time is estimated to be ${_data_vacuum_time.toFixed(1)} hours and scaled time of ${_worst_data_vacuum_time.toFixed(1)} hours, either you should (1) upgrade the data volume to have a better performance with higher IOPS and throughput, or (2) leverage pg_cron, pg_timetable, or any cron-scheduled alternative to schedule manual vacuuming when age is coming to normal vacuuming threshold.`)
const _decre_xid=generalized_mean([24+(18-_transaction_coef)*_transaction_coef,_worst_data_vacuum_time],0.5)
const _decre_mxid=generalized_mean([24+(12-_transaction_coef)*_transaction_coef,_worst_data_vacuum_time],0.5)
let xid_failsafe_age=Math.max(1_900_000_000-_transaction_rate*_decre_xid,1_400_000_000)
xid_failsafe_age=realign_value(xid_failsafe_age,500*K10)[request.options.align_index]
let mxid_failsafe_age=Math.max(1_900_000_000-_transaction_rate*_decre_mxid,1_400_000_000)
mxid_failsafe_age=realign_value(mxid_failsafe_age,500*K10)[request.options.align_index]
if('vacuum_failsafe_age'in managed_cache){_ApplyItmTune('vacuum_failsafe_age',xid_failsafe_age,PG_SCOPE.MAINTENANCE,response)}
if('vacuum_multixact_failsafe_age'in managed_cache){_ApplyItmTune('vacuum_multixact_failsafe_age',mxid_failsafe_age,PG_SCOPE.MAINTENANCE,response)}
let _decre_max_xid=Math.max(1.25*_worst_data_vacuum_time,generalized_mean([36+(24-_transaction_coef)*_transaction_coef,1.5*_worst_data_vacuum_time],0.5))
let _decre_max_mxid=Math.max(1.25*_worst_data_vacuum_time,generalized_mean([24+(20-_transaction_coef)*_transaction_coef,1.25*_worst_data_vacuum_time],0.5))
let xid_max_age=Math.max(Math.floor(0.95*managed_cache['autovacuum_freeze_max_age']),0.85*xid_failsafe_age-_transaction_rate*_decre_max_xid)
xid_max_age=realign_value(xid_max_age,250*K10)[request.options.align_index]
let mxid_max_age=Math.max(Math.floor(0.95*managed_cache['autovacuum_multixact_freeze_max_age']),0.85*mxid_failsafe_age-_transaction_rate*_decre_max_mxid)
mxid_max_age=realign_value(mxid_max_age,250*K10)[request.options.align_index]
if(xid_max_age<=Math.floor(1.15*managed_cache['autovacuum_freeze_max_age'])||mxid_max_age<=Math.floor(1.05*managed_cache['autovacuum_multixact_freeze_max_age'])){console.warn(`WARNING: The autovacuum freeze max age is already at the minimum value. Please check if you can have a 
            better SSD for data volume or apply sharding or partitioned to distribute data across servers or tables.`)}
_ApplyItmTune('autovacuum_freeze_max_age',xid_max_age,PG_SCOPE.MAINTENANCE,response)
_ApplyItmTune('autovacuum_multixact_freeze_max_age',mxid_max_age,PG_SCOPE.MAINTENANCE,response)
const updates={[PG_SCOPE.MAINTENANCE]:['vacuum_freeze_table_age','vacuum_multixact_freeze_table_age']}
_TriggerAutoTune(updates,request,response)
let xid_min_age=cap_value(_transaction_rate*24,20*M10,managed_cache['autovacuum_freeze_max_age']*0.25)
xid_min_age=realign_value(xid_min_age,250*K10)[request.options.align_index]
_ApplyItmTune('vacuum_freeze_min_age',xid_min_age,PG_SCOPE.MAINTENANCE,response)
let multixact_min_age=cap_value(_transaction_rate*18,2*M10,managed_cache['autovacuum_multixact_freeze_max_age']*0.25)
multixact_min_age=realign_value(multixact_min_age,250*K10)[request.options.align_index]
_ApplyItmTune('vacuum_multixact_freeze_min_age',multixact_min_age,PG_SCOPE.MAINTENANCE,response)
return null;}
function _wal_integrity_buffer_size_tune(request,response){console.info(`===== Data Integrity and Write-Ahead Log Tuning =====`)
console.info(`Start tuning the WAL of the PostgreSQL database server based on the data integrity and HA requirements.`)
console.info(`Impacted Attributes: wal_level, max_wal_senders, max_replication_slots, wal_sender_timeout,
        log_replication_commands, synchronous_commit, full_page_writes, fsync, logical_decoding_work_mem`)
const replication_level=request.options.max_backup_replication_tool
const num_stream_replicas=request.options.max_num_stream_replicas_on_primary
const num_logical_replicas=request.options.max_num_logical_replicas_on_primary
const num_replicas=num_stream_replicas+num_logical_replicas
const managed_cache=response.get_managed_cache(_TARGET_SCOPE)
const _kwargs=request.options.tuning_kwargs
let after_wal_level=managed_cache['wal_level']
if(replication_level===PG_BACKUP_TOOL.PG_LOGICAL||num_logical_replicas>0){after_wal_level='logical'}else if(replication_level===PG_BACKUP_TOOL.PG_BASEBACKUP||num_stream_replicas>0||num_replicas>0){after_wal_level='replica'}else if((replication_level===PG_BACKUP_TOOL.PG_DUMP||replication_level===PG_BACKUP_TOOL.DISK_SNAPSHOT)&&num_replicas===0){after_wal_level='minimal'}
_ApplyItmTune('wal_level',after_wal_level,PG_SCOPE.ARCHIVE_RECOVERY_BACKUP_RESTORE,response)
_ApplyItmTune('log_replication_commands',after_wal_level!=='minimal'?'on':'off',PG_SCOPE.LOGGING,response)
let reserved_wal_senders=_DEFAULT_WAL_SENDERS[0]
if(after_wal_level!=='minimal'){if(num_replicas>=8){reserved_wal_senders=_DEFAULT_WAL_SENDERS[1]}else if(num_replicas>=16){reserved_wal_senders=_DEFAULT_WAL_SENDERS[2]}}
let after_max_wal_senders=reserved_wal_senders+(after_wal_level!=='minimal'?num_replicas:0)
_ApplyItmTune('max_wal_senders',after_max_wal_senders,PG_SCOPE.ARCHIVE_RECOVERY_BACKUP_RESTORE,response)
_ApplyItmTune('max_replication_slots',after_max_wal_senders,PG_SCOPE.ARCHIVE_RECOVERY_BACKUP_RESTORE,response)
if(request.options.offshore_replication&&after_wal_level!=='minimal'){const after_wal_sender_timeout=Math.max(10*MINUTE,Math.ceil(MINUTE*(2+(num_replicas/4))))
_ApplyItmTune('wal_sender_timeout',after_wal_sender_timeout,PG_SCOPE.ARCHIVE_RECOVERY_BACKUP_RESTORE,response)}
if(after_wal_level!=='logical'){_ApplyItmTune('logical_decoding_work_mem',64*Mi,PG_SCOPE.ARCHIVE_RECOVERY_BACKUP_RESTORE,response)}
if(request.options.opt_transaction_lost>=PG_PROFILE_OPTMODE.SPIDEY){let after_synchronous_commit=managed_cache['synchronous_commit']
if(after_wal_level==='minimal'){after_synchronous_commit='off'
console.warn(`
                WARNING: The synchronous_commit is off -> If data integrity is less important to you than response times
                (for example, if you are running a social networking application or processing logs) you can turn this off,
                making your transaction logs asynchronous. This can result in up to wal_buffers or wal_writer_delay * 2
                (3 times on worst case) worth of data in an unexpected shutdown, but your database will not be corrupted.
                Note that you can also set this on a per-session basis, allowing you to mix “lossy” and “safe” transactions,
                which is a better approach for most applications. It is recommended to set it to local or remote_write if
                you do not prefer lossy transactions.
            `)}else if(num_replicas===0){after_synchronous_commit='local'}else{after_synchronous_commit='remote_write'}
console.warn(`
                WARNING: User allows the lost transaction during crash but with ${after_wal_level} wal_level at
                profile ${request.options.opt_transaction_lost} but data loss could be there. Only enable this during
                testing only.
            `)
_ApplyItmTune('synchronous_commit',after_synchronous_commit,PG_SCOPE.ARCHIVE_RECOVERY_BACKUP_RESTORE,response)
if(request.options.opt_transaction_lost>=PG_PROFILE_OPTMODE.OPTIMUS_PRIME){_ApplyItmTune('full_page_writes','off',PG_SCOPE.ARCHIVE_RECOVERY_BACKUP_RESTORE,response)
if(request.options.opt_transaction_lost>=PG_PROFILE_OPTMODE.PRIMORDIAL&&request.options.operating_system==='linux'){_ApplyItmTune('fsync','off',PG_SCOPE.ARCHIVE_RECOVERY_BACKUP_RESTORE,response)}}}
console.info(`Start tuning the WAL size of the PostgreSQL database server based on the WAL disk sizing\nImpacted Attributes: min_wal_size, max_wal_size, wal_keep_size, archive_timeout, checkpoint_timeout, checkpoint_warning`)
const _wal_disk_size=request.options.wal_spec.disk_usable_size
let after_max_wal_size=cap_value(Math.floor(_wal_disk_size*_kwargs.max_wal_size_ratio),Math.min(64*_kwargs.wal_segment_size,4*Gi),64*Gi)
after_max_wal_size=realign_value(after_max_wal_size,16*_kwargs.wal_segment_size)[request.options.align_index]
_ApplyItmTune('max_wal_size',after_max_wal_size,PG_SCOPE.ARCHIVE_RECOVERY_BACKUP_RESTORE,response)
let after_min_wal_size=cap_value(Math.floor(_wal_disk_size*_kwargs.min_wal_size_ratio),Math.min(32*_kwargs.wal_segment_size,2*Gi),Math.floor(1.05*after_max_wal_size))
after_min_wal_size=realign_value(after_min_wal_size,8*_kwargs.wal_segment_size)[request.options.align_index]
_ApplyItmTune('min_wal_size',after_min_wal_size,PG_SCOPE.ARCHIVE_RECOVERY_BACKUP_RESTORE,response)
let after_wal_keep_size=cap_value(Math.floor(_wal_disk_size*_kwargs.wal_keep_size_ratio),Math.min(32*_kwargs.wal_segment_size,2*Gi),64*Gi)
after_wal_keep_size=realign_value(after_wal_keep_size,16*_kwargs.wal_segment_size)[request.options.align_index]
_ApplyItmTune('wal_keep_size',after_wal_keep_size,PG_SCOPE.ARCHIVE_RECOVERY_BACKUP_RESTORE,response)
const _wal_scale_factor=Math.floor(Math.log2(_kwargs.wal_segment_size/BASE_WAL_SEGMENT_SIZE))
const after_archive_timeout=realign_value(cap_value(managed_cache['archive_timeout']+Math.floor(MINUTE*(_wal_scale_factor*10-num_replicas/2*5)),30*MINUTE,2*HOUR),Math.floor(MINUTE/4))[request.options.align_index]
_ApplyItmTune('archive_timeout',after_archive_timeout,PG_SCOPE.ARCHIVE_RECOVERY_BACKUP_RESTORE,response)
console.info(`Start tuning the WAL integrity of the PostgreSQL database server based on the data integrity and provided allowed time of data transaction loss.\nImpacted Attributes: wal_buffers, wal_writer_delay`)
const after_wal_writer_delay=Math.floor(request.options.max_time_transaction_loss_allow_in_millisecond/3.25)
_ApplyItmTune('wal_writer_delay',after_wal_writer_delay,PG_SCOPE.ARCHIVE_RECOVERY_BACKUP_RESTORE,response)
const wal_tput=request.options.wal_spec.perf()[0]
const data_amount_ratio_input=0.5+0.5*request.options.opt_wal_buffers
const transaction_loss_ratio=(2+Math.floor(request.options.opt_wal_buffers/2))/3.25
const decay_rate=16*DB_PAGE_SIZE
let current_wal_buffers=realign_value(managed_cache['wal_buffers'],Math.min(_kwargs.wal_segment_size,64*Mi))[1]
let transaction_loss_time=request.options.max_time_transaction_loss_allow_in_millisecond*transaction_loss_ratio
while(transaction_loss_time<=wal_time(current_wal_buffers,data_amount_ratio_input,_kwargs.wal_segment_size,after_wal_writer_delay,wal_tput,request.options,managed_cache['wal_init_zero'])['total_time']){current_wal_buffers-=decay_rate}
_ApplyItmTune('wal_buffers',current_wal_buffers,PG_SCOPE.ARCHIVE_RECOVERY_BACKUP_RESTORE,response)
const wal_time_report=wal_time(current_wal_buffers,data_amount_ratio_input,_kwargs.wal_segment_size,after_wal_writer_delay,wal_tput,request.options,managed_cache['wal_init_zero'])['msg']
console.info(`The wal_buffers is set to ${bytesize_to_hr(current_wal_buffers)} -> ${wal_time_report}.`)
return null}
function _get_wrk_mem_func(){let result={[PG_PROFILE_OPTMODE.SPIDEY]:(options,response)=>response.report(options,true,true)[1],[PG_PROFILE_OPTMODE.PRIMORDIAL]:(options,response)=>response.report(options,false,true)[1]}
result[PG_PROFILE_OPTMODE.OPTIMUS_PRIME]=(options,response)=>{return(result[PG_PROFILE_OPTMODE.SPIDEY](options,response)+result[PG_PROFILE_OPTMODE.PRIMORDIAL](options,response))/2}
return result}
function _get_wrk_mem(optmode,options,response){return _get_wrk_mem_func()[optmode](options,response)}
function _hash_mem_adjust(request,response){const managed_cache=response.get_managed_cache(_TARGET_SCOPE)
const current_work_mem=managed_cache['work_mem']
let after_hash_mem_multiplier=2.0
let workload_type=request.options.workload_type
if(workload_type===PG_WORKLOAD.HTAP||workload_type===PG_WORKLOAD.OLTP||workload_type===PG_WORKLOAD.VECTOR){after_hash_mem_multiplier=Math.min(2.0+0.125*Math.floor(current_work_mem/(40*Mi)),3.0)}else if(workload_type===PG_WORKLOAD.OLAP){after_hash_mem_multiplier=Math.min(2.0+0.150*Math.floor(current_work_mem/(40*Mi)),3.0)}
_ApplyItmTune('hash_mem_multiplier',after_hash_mem_multiplier,PG_SCOPE.MEMORY,response,`by workload: ${workload_type} and working memory ${current_work_mem}`)
return null;}
function _wrk_mem_tune_oneshot(request,response,shared_buffers_ratio_increment,max_work_buffer_ratio_increment,tuning_items){const _kwargs=request.options.tuning_kwargs
let sbuf_ok=false
let wbuf_ok=false
if(_kwargs.shared_buffers_ratio+shared_buffers_ratio_increment<=1.0){_kwargs.shared_buffers_ratio+=shared_buffers_ratio_increment
sbuf_ok=true}
if(_kwargs.max_work_buffer_ratio+max_work_buffer_ratio_increment<=1.0){_kwargs.max_work_buffer_ratio+=max_work_buffer_ratio_increment
wbuf_ok=true}
if(!sbuf_ok&&!wbuf_ok){console.warn(`WARNING: The shared_buffers and work_mem are not increased as the condition is met 
            or being unchanged, or converged -> Stop ...`)}
_TriggerAutoTune(tuning_items,request,response)
_hash_mem_adjust(request,response)
return[sbuf_ok,wbuf_ok]}
function _wrk_mem_tune(request,response){console.info(`===== Memory Usage Tuning =====`)
_hash_mem_adjust(request,response)
if(request.options.opt_mem_pool===PG_PROFILE_OPTMODE.NONE){return null;}
console.info(`Start tuning the memory usage based on the specific workload profile. \nImpacted attributes: shared_buffers, temp_buffers, work_mem, vacuum_buffer_usage_limit, effective_cache_size, maintenance_work_mem`)
const _kwargs=request.options.tuning_kwargs
let ram=request.options.usable_ram
let srv_mem_str=bytesize_to_hr(ram)
let stop_point=_kwargs.max_normal_memory_usage
let rollback_point=Math.min(stop_point+0.0075,1.0)
let boost_ratio=1/560
const keys={[PG_SCOPE.MEMORY]:['shared_buffers','temp_buffers','work_mem'],[PG_SCOPE.QUERY_TUNING]:['effective_cache_size',],[PG_SCOPE.MAINTENANCE]:['maintenance_work_mem','vacuum_buffer_usage_limit']}
function _show_tuning_result(first_text){console.info(first_text);for(const[scope,key_itm_list]of Object.entries(keys)){let m_items=response.get_managed_items(_TARGET_SCOPE,scope)
for(const key_itm of key_itm_list){if(!(key_itm in m_items)){continue}
console.info(`\t - ${m_items[key_itm].transform_keyname()}: ${m_items[key_itm].out_display()} (in postgresql.conf) or detailed: ${m_items[key_itm].after} (in bytes).`)}}}
_show_tuning_result('Result (before): ')
let _mem_check_string=Object.entries(_get_wrk_mem_func()).map(([scope,func])=>`${scope}=${bytesize_to_hr(func(request.options, response))}`).join('; ');console.info(`The working memory usage based on memory profile is ${_mem_check_string} before tuning. NOTICE: Expected maximum memory usage in normal condition: ${(stop_point * 100).toFixed(2)} (%) of ${srv_mem_str} or ${bytesize_to_hr(Math.floor(ram * stop_point))}.`)
const shared_buffers_ratio_increment=boost_ratio*2.0*_kwargs.mem_pool_tuning_ratio
const max_work_buffer_ratio_increment=boost_ratio*2.0*(1-_kwargs.mem_pool_tuning_ratio)
let managed_cache=response.get_managed_cache(_TARGET_SCOPE)
let num_conn=managed_cache['max_connections']-managed_cache['superuser_reserved_connections']-managed_cache['reserved_connections']
let mem_conn=num_conn*_kwargs.single_memory_connection_overhead*_kwargs.memory_connection_to_dedicated_os_ratio/ram
let active_connection_ratio={[PG_PROFILE_OPTMODE.SPIDEY]:1.0/_kwargs.effective_connection_ratio,[PG_PROFILE_OPTMODE.OPTIMUS_PRIME]:(1.0+_kwargs.effective_connection_ratio)/(2*_kwargs.effective_connection_ratio),[PG_PROFILE_OPTMODE.PRIMORDIAL]:1.0}
let hash_mem=generalized_mean([1,managed_cache['hash_mem_multiplier']],_kwargs.hash_mem_usage_level)
let work_mem_single=(1-_kwargs.temp_buffers_ratio)*hash_mem
let TBk=_kwargs.temp_buffers_ratio+work_mem_single
if(_kwargs.mem_pool_parallel_estimate){let parallel_scale_nonfull=response.calc_worker_in_parallel(request.options,Math.ceil(_kwargs.effective_connection_ratio*num_conn))['work_mem_parallel_scale']
let parallel_scale_full=response.calc_worker_in_parallel(request.options,num_conn)['work_mem_parallel_scale']
if(request.options.opt_mem_pool===PG_PROFILE_OPTMODE.SPIDEY){TBk=_kwargs.temp_buffers_ratio+work_mem_single*parallel_scale_full}else if(request.options.opt_mem_pool===PG_PROFILE_OPTMODE.OPTIMUS_PRIME){TBk=_kwargs.temp_buffers_ratio+work_mem_single*(parallel_scale_full+parallel_scale_nonfull)/2}else{TBk=_kwargs.temp_buffers_ratio+work_mem_single*parallel_scale_nonfull}}
TBk*=active_connection_ratio[request.options.opt_mem_pool]
const A=_kwargs.shared_buffers_ratio*ram
const B=shared_buffers_ratio_increment*ram
const C=max_work_buffer_ratio_increment
const D=_kwargs.max_work_buffer_ratio
const E=ram-mem_conn-A
const F=TBk
const LIMIT=stop_point*ram-mem_conn
const a=C*F*(0-B)
const b=B+F*C*E-B*D*F
const c=A+F*E*D-LIMIT
const x=((-b+Math.sqrt(b**2-4*a*c))/(2*a))
console.log(`With A=${A}, B=${B}, C=${C}, D=${D}, E=${E}, F=${F}, LIMIT=${LIMIT} -> The quadratic function is: ${a}x^2 + ${b}x + ${c} = 0 -> The number of steps to reach the optimal point is ${x.toFixed(4)} steps.`)
_wrk_mem_tune_oneshot(request,response,shared_buffers_ratio_increment*x,max_work_buffer_ratio_increment*x,keys)
let working_memory=_get_wrk_mem(request.options.opt_mem_pool,request.options,response)
_mem_check_string=Object.entries(_get_wrk_mem_func()).map(([scope,func])=>`${scope}=${bytesize_to_hr(func(request.options, response))}`).join('; ');console.info(`The working memory usage based on memory profile increased to ${bytesize_to_hr(working_memory)} 
        or ${(working_memory / ram * 100).toFixed(2)} (%) of ${srv_mem_str} after ${x.toFixed(2)} steps. This 
        results in memory usage of all profiles are ${_mem_check_string} `);let bump_step=0
while(working_memory<stop_point*ram){_wrk_mem_tune_oneshot(request,response,shared_buffers_ratio_increment,max_work_buffer_ratio_increment,keys)
working_memory=_get_wrk_mem(request.options.opt_mem_pool,request.options,response)
bump_step+=1}
let decay_step=0
while(working_memory>=rollback_point*ram){_wrk_mem_tune_oneshot(request,response,0-shared_buffers_ratio_increment,0-max_work_buffer_ratio_increment,keys)
working_memory=_get_wrk_mem(request.options.opt_mem_pool,request.options,response)
decay_step+=1}
console.info(`The optimal point is found after ${bump_step} bump steps and ${decay_step} decay steps (larger than 3 is a signal of incorrect algorithm).`)
console.info(`The shared_buffers_ratio is now ${_kwargs.shared_buffers_ratio.toFixed(5)}.`)
console.info(`The max_work_buffer_ratio is now ${_kwargs.max_work_buffer_ratio.toFixed(5)}.`)
_show_tuning_result('Result (after): ')
_mem_check_string=Object.entries(_get_wrk_mem_func()).map(([scope,func])=>`${scope}=${bytesize_to_hr(func(request.options, response))}`).join('; ');console.info(`The working memory usage based on memory profile on all profiles are ${_mem_check_string}.`);const _data_tput=request.options.data_index_spec.perf()[0]
const _data_iops=request.options.data_index_spec.perf()[1]
const _data_trans_tput=0.70*generalized_mean([PG_DISK_PERF.iops_to_throughput(_data_iops),_data_tput],-2.5)
let _shared_buffers_ratio=0.30
if(request.options.workload_type in[PG_WORKLOAD.OLAP,PG_WORKLOAD.VECTOR]){_shared_buffers_ratio=0.15}
let _data_amount=Math.min(Math.floor(managed_cache['shared_buffers']*_shared_buffers_ratio/Mi),Math.floor(managed_cache['effective_cache_size']/Ki),Math.floor(managed_cache['max_wal_size']/Ki),)
let min_ckpt_time=Math.ceil(_data_amount*1/_data_trans_tput)
console.info(`The minimum checkpoint time is estimated to be ${min_ckpt_time.toFixed(1)} seconds under estimation of ${_data_amount} MiB of data amount and ${_data_trans_tput.toFixed(2)} MiB/s of disk throughput.`)
const after_checkpoint_timeout=realign_value(Math.max(managed_cache['checkpoint_timeout']+
Math.floor(Math.floor(Math.log2(_kwargs.wal_segment_size/BASE_WAL_SEGMENT_SIZE))*7.5*MINUTE),min_ckpt_time/managed_cache['checkpoint_completion_target']),Math.floor(MINUTE/2))[request.options.align_index]
_ApplyItmTune('checkpoint_timeout',after_checkpoint_timeout,PG_SCOPE.ARCHIVE_RECOVERY_BACKUP_RESTORE,response)
_ApplyItmTune('checkpoint_warning',Math.floor(after_checkpoint_timeout/10),PG_SCOPE.ARCHIVE_RECOVERY_BACKUP_RESTORE,response)
return null;}
function _logger_tune(request,response){console.info('===== Logging and Query Statistics Tuning =====')
console.info(`Start tuning the logging and query statistics on the PostgreSQL database server based on the database workload and production guidelines. \nImpacted attributes: track_activity_query_size, log_parameter_max_length, log_parameter_max_length_on_error, log_min_duration_statement, auto_explain.log_min_duration, track_counts, track_io_timing, track_wal_io_timing, `)
const _kwargs=request.options.tuning_kwargs;const log_length=realign_value(_kwargs.max_query_length_in_bytes,64)[request.options.align_index]
_ApplyItmTune('track_activity_query_size',log_length,PG_SCOPE.QUERY_TUNING,response)
_ApplyItmTune('log_parameter_max_length',log_length,PG_SCOPE.LOGGING,response)
_ApplyItmTune('log_parameter_max_length_on_error',log_length,PG_SCOPE.LOGGING,response)
const log_min_duration=realign_value(_kwargs.max_runtime_ms_to_log_slow_query,20)[request.options.align_index]
_ApplyItmTune('log_min_duration_statement',log_min_duration,PG_SCOPE.LOGGING,response)
let explain_min_duration=Math.floor(log_min_duration*_kwargs.max_runtime_ratio_to_explain_slow_query)
explain_min_duration=realign_value(explain_min_duration,20)[request.options.align_index]
_ApplyItmTune('auto_explain.log_min_duration',explain_min_duration,PG_SCOPE.EXTRA,response)
_ApplyItmTune('track_counts','on',PG_SCOPE.QUERY_TUNING,response)
_ApplyItmTune('track_io_timing','on',PG_SCOPE.QUERY_TUNING,response)
_ApplyItmTune('track_wal_io_timing','on',PG_SCOPE.QUERY_TUNING,response)
_ApplyItmTune('auto_explain.log_timing','on',PG_SCOPE.EXTRA,response)
return null;}
function correction_tune(request,response){if(!request.options.enable_database_correction_tuning){console.warn('The database correction tuning is disabled by the user -> Skip the workload tuning')
return null;}
_conn_cache_query_timeout_tune(request,response)
_generic_disk_bgwriter_vacuum_wraparound_vacuum_tune(request,response)
_wal_integrity_buffer_size_tune(request,response)
_logger_tune(request,response)
_wrk_mem_tune(request,response)
return null;}
function _get_text_element(element){let el=document.getElementById(element)
if(el.type==='range'||el.type==='number'){return el.step.includes('.')?parseFloat(el.value):parseInt(el.value);}else if(el.type==='text'){return el.value;}else if(el.type==='select-one'){return el.value;}
return'';}
function _get_checkbox_element(element){let el=document.getElementById(element)
if(el.type==='checkbox'){return el.checked;}
return'';}
function _build_disk_from_backend(data){return new PG_DISK_PERF({'random_iops_spec':data.random_iops_spec,'random_iops_scale_factor':data.random_iops_scale_factor!==null?data.random_iops_scale_factor:1.0,'throughput_spec':data.throughput_spec,'throughput_scale_factor':data.throughput_scale_factor!==null?data.throughput_scale_factor:1.0,'disk_usable_size':data.disk_usable_size,'num_disks':data.num_disks!==null?data.num_disks:1,'per_scale_in_raid':data.per_scale_in_raid!==null?data.per_scale_in_raid:0.75})}
function _build_disk_from_html(name='data_index_spec'){return{'random_iops_spec':_get_text_element(`${name}.random_iops`),'throughput_spec':_get_text_element(`${name}.throughput`),'disk_usable_size':_get_text_element(`${name}.disk_usable_size_in_gib`)*Gi,};}
function _build_keywords_from_backend(data){return new PG_TUNE_USR_KWARGS({user_max_connections:data.user_max_connections,cpu_to_connection_scale_ratio:data.cpu_to_connection_scale_ratio,superuser_reserved_connections_scale_ratio:data.superuser_reserved_connections_scale_ratio,single_memory_connection_overhead:data.single_memory_connection_overhead,memory_connection_to_dedicated_os_ratio:data.memory_connection_to_dedicated_os_ratio,effective_cache_size_available_ratio:data.effective_cache_size_available_ratio,shared_buffers_ratio:data.shared_buffers_ratio,max_work_buffer_ratio:data.max_work_buffer_ratio,effective_connection_ratio:data.effective_connection_ratio,temp_buffers_ratio:data.temp_buffers_ratio,max_normal_memory_usage:data.max_normal_memory_usage,mem_pool_tuning_ratio:data.mem_pool_tuning_ratio,hash_mem_usage_level:data.hash_mem_usage_level,mem_pool_parallel_estimate:data.mem_pool_parallel_estimate,max_query_length_in_bytes:data.max_query_length_in_bytes,max_runtime_ms_to_log_slow_query:data.max_runtime_ms_to_log_slow_query,max_runtime_ratio_to_explain_slow_query:data.max_runtime_ratio_to_explain_slow_query,wal_segment_size:BASE_WAL_SEGMENT_SIZE,min_wal_size_ratio:data.min_wal_size_ratio,max_wal_size_ratio:data.max_wal_size_ratio,wal_keep_size_ratio:data.wal_keep_size_ratio,autovacuum_utilization_ratio:data.autovacuum_utilization_ratio,vacuum_safety_level:data.vacuum_safety_level})}
function _build_keywords_from_html(name='keywords'){return{'user_max_connections':_get_text_element(`${name}.user_max_connections`),'cpu_to_connection_scale_ratio':_get_text_element(`${name}.cpu_to_connection_scale_ratio`),'superuser_reserved_connections_scale_ratio':_get_text_element(`${name}.superuser_reserved_connections_scale_ratio`),'single_memory_connection_overhead':_get_text_element(`${name}.single_memory_connection_overhead_in_kib`)*Ki,'memory_connection_to_dedicated_os_ratio':_get_text_element(`${name}.memory_connection_to_dedicated_os_ratio`),'effective_cache_size_available_ratio':_get_text_element(`${name}.effective_cache_size_available_ratio`),'shared_buffers_ratio':_get_text_element(`${name}.shared_buffers_ratio`),'max_work_buffer_ratio':_get_text_element(`${name}.max_work_buffer_ratio`),'effective_connection_ratio':_get_text_element(`${name}.effective_connection_ratio`),'temp_buffers_ratio':_get_text_element(`${name}.temp_buffers_ratio`),'max_normal_memory_usage':_get_text_element(`${name}.max_normal_memory_usage`),'mem_pool_tuning_ratio':_get_text_element(`${name}.mem_pool_tuning_ratio`),'hash_mem_usage_level':_get_text_element(`${name}.hash_mem_usage_level`),'mem_pool_parallel_estimate':_get_checkbox_element(`${name}.mem_pool_parallel_estimate`)??true,'max_query_length_in_bytes':_get_text_element(`${name}.max_query_length_in_bytes`),'max_runtime_ms_to_log_slow_query':_get_text_element(`${name}.max_runtime_ms_to_log_slow_query`),'max_runtime_ratio_to_explain_slow_query':_get_text_element(`${name}.max_runtime_ratio_to_explain_slow_query`),'wal_segment_size':BASE_WAL_SEGMENT_SIZE*Math.pow(2,(_get_text_element(`${name}.wal_segment_size_scale`))),'min_wal_size_ratio':_get_text_element(`${name}.min_wal_size_ratio`),'max_wal_size_ratio':_get_text_element(`${name}.max_wal_size_ratio`),'wal_keep_size_ratio':_get_text_element(`${name}.wal_keep_size_ratio`),'autovacuum_utilization_ratio':_get_text_element(`${name}.autovacuum_utilization_ratio`),'vacuum_safety_level':_get_text_element(`${name}.vacuum_safety_level`),}}
function _build_options_from_backend(data){return new PG_TUNE_USR_OPTIONS({'workload_type':data.workload_type,'workload_profile':data.workload_profile,'pgsql_version':data.pgsql_version,'operating_system':data.operating_system,'vcpu':data.vcpu,'total_ram':data.total_ram,'base_kernel_memory_usage':data.base_kernel_memory_usage,'base_monitoring_memory_usage':data.base_monitoring_memory_usage,'opt_mem_pool':data.opt_mem_pool,'data_index_spec':_build_disk_from_backend(data.data_index_spec),'wal_spec':_build_disk_from_backend(data.wal_spec),'max_backup_replication_tool':data.max_backup_replication_tool,'opt_transaction_lost':data.opt_transaction_lost,'opt_wal_buffers':data.opt_wal_buffers,'max_time_transaction_loss_allow_in_millisecond':data.max_time_transaction_loss_allow_in_millisecond,'max_num_stream_replicas_on_primary':data.max_num_stream_replicas_on_primary,'max_num_logical_replicas_on_primary':data.max_num_logical_replicas_on_primary,'offshore_replication':data.offshore_replication,'tuning_kwargs':_build_keywords_from_backend(data.tuning_kwargs),'database_size_in_gib':data.database_size_in_gib,'num_write_transaction_per_hour_on_workload':data.num_write_transaction_per_hour_on_workload,'enable_database_general_tuning':data.enable_database_general_tuning,'enable_database_correction_tuning':data.enable_database_correction_tuning,'align_index':data.align_index??1,})}
function _build_options_from_html(){let monitoring_memory=parseInt(_get_text_element(`base_monitoring_memory_usage_in_mib`));monitoring_memory=Math.min(monitoring_memory,Math.max(monitoring_memory,monitoring_memory*Mi));let kernel_memory=parseInt(_get_text_element(`base_kernel_memory_usage_in_mib`));kernel_memory=Math.min(kernel_memory,Math.max(kernel_memory,kernel_memory*Mi));return{'workload_type':PG_WORKLOAD[_get_text_element(`workload_type`).toUpperCase()],'workload_profile':PG_SIZING.fromString(_get_text_element(`workload_profile`)),'pgsql_version':parseInt(_get_text_element(`pgsql_version`)),'operating_system':_get_text_element(`operating_system`),'vcpu':_get_text_element(`vcpu`),'total_ram':_get_text_element(`total_ram_in_gib`)*Gi,'base_kernel_memory_usage':kernel_memory,'base_monitoring_memory_usage':monitoring_memory,'opt_mem_pool':PG_PROFILE_OPTMODE[_get_text_element(`opt_mem_pool`).toUpperCase()],'tuning_kwargs':_build_keywords_from_html(`keywords`),'data_index_spec':_build_disk_from_html(`data_index_spec`),'wal_spec':_build_disk_from_html(`wal_spec`),'database_size_in_gib':parseInt(_get_text_element(`database_size_in_gib`)),'num_write_transaction_per_hour_on_workload':_get_text_element(`num_write_transaction_per_hour_on_workload`),'max_backup_replication_tool':PG_BACKUP_TOOL[_get_text_element(`max_backup_replication_tool`).toUpperCase()],'opt_transaction_lost':PG_PROFILE_OPTMODE[_get_text_element(`opt_transaction_lost`).toUpperCase()],'opt_wal_buffers':PG_PROFILE_OPTMODE[_get_text_element(`opt_wal_buffers`).toUpperCase()],'max_time_transaction_loss_allow_in_millisecond':parseInt(_get_text_element(`max_time_transaction_loss_allow_in_millisecond`)),'max_num_stream_replicas_on_primary':parseInt(_get_text_element(`max_num_stream_replicas_on_primary`)),'max_num_logical_replicas_on_primary':parseInt(_get_text_element(`max_num_logical_replicas_on_primary`)),'offshore_replication':_get_checkbox_element(`offshore_replication`)??false,'enable_database_general_tuning':_get_checkbox_element(`enable_database_general_tuning`)??true,'enable_database_correction_tuning':_get_checkbox_element(`enable_database_correction_tuning`)??true,'align_index':1,}}
function _build_request_from_backend(data){return new PG_TUNE_REQUEST({'options':_build_options_from_backend(data.options),'include_comment':data.include_comment,'custom_style':data.custom_style,'backup_settings':data.backup_settings,'analyze_with_full_connection_use':data.analyze_with_full_connection_use,'ignore_non_performance_setting':data.ignore_non_performance_setting,'output_format':data.output_format,})}
function _build_request_from_html(){return{'options':_build_options_from_html(),'include_comment':_get_checkbox_element(`include_comment`),'custom_style':_get_checkbox_element(`custom_style`),'backup_settings':_get_checkbox_element(`backup_settings`),'analyze_with_full_connection_use':_get_checkbox_element(`analyze_with_full_connection_use`),'ignore_non_performance_setting':_get_checkbox_element(`ignore_non_performance_setting`),'output_format':_get_text_element(`output_format`),}}
function web_optimize(request){let response=new PG_TUNE_RESPONSE();let items={13:DB13_CONFIG_PROFILE,14:DB14_CONFIG_PROFILE,15:DB15_CONFIG_PROFILE,16:DB16_CONFIG_PROFILE,17:DB17_CONFIG_PROFILE,18:DB18_CONFIG_PROFILE,}
let tuning_items=items[parseInt(request.options.pgsql_version)];if(tuning_items===null||tuning_items===undefined){tuning_items=DB13_CONFIG_PROFILE;}
console.log(request);Optimize(request,response,PGTUNER_SCOPE.DATABASE_CONFIG,tuning_items);if(request.options.enable_database_correction_tuning){correction_tune(request,response);}
let exclude_names=['archive_command','restore_command','archive_cleanup_command','recovery_end_command','log_directory',];if(request.ignore_non_performance_setting){exclude_names.push('deadlock_timeout','transaction_timeout','idle_session_timeout','idle_replication_slot_timeout','log_autovacuum_min_duration','log_checkpoints','log_connections','log_disconnections','log_duration','log_error_verbosity','log_line_prefix','log_lock_waits','log_recovery_conflict_waits','log_statement','log_replication_commands','log_min_error_statement','log_startup_progress_interval','log_lock_failure',)}
if(request.options.operating_system==='windows'){exclude_names.push('checkpoint_flush_after','bgwriter_flush_after','wal_writer_flush_after','backend_flush_after');}
const content=response.generate_content(PGTUNER_SCOPE.DATABASE_CONFIG,request,exclude_names);const mem_report=response.report(request.options,request.analyze_with_full_connection_use,false)[0];return{'content':content,'mem_report':mem_report,'response':response,}}